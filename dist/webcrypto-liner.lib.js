var liner =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzPzlhYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChvW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9OyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "./node_modules/webcrypto-core/dist/webcrypto-core.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/webcrypto-core/dist/webcrypto-core.es.js ***!
  \***************************************************************/
/*! exports provided: WebCryptoError, AlgorithmError, CryptoKeyError, PrepareAlgorithm, PrepareData, BaseCrypto, AlgorithmNames, Base64Url, SubtleCrypto, Aes, AesAlgorithmError, AesWrapKey, AesEncrypt, AesECB, AesCBC, AesCTR, AesGCM, AesKW, RsaKeyGenParamsError, RsaHashedImportParamsError, Rsa, RsaSSA, RsaPSSParamsError, RsaPSS, RsaOAEPParamsError, RsaOAEP, EcKeyGenParamsError, Ec, EcAlgorithmError, EdDSA, EcDSA, EcDH, ShaAlgorithms, Sha */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebCryptoError\", function() { return WebCryptoError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlgorithmError\", function() { return AlgorithmError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CryptoKeyError\", function() { return CryptoKeyError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrepareAlgorithm\", function() { return PrepareAlgorithm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrepareData\", function() { return PrepareData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseCrypto\", function() { return BaseCrypto; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlgorithmNames\", function() { return AlgorithmNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Base64Url\", function() { return Base64Url; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubtleCrypto\", function() { return SubtleCrypto; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Aes\", function() { return Aes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesAlgorithmError\", function() { return AesAlgorithmError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesWrapKey\", function() { return AesWrapKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesEncrypt\", function() { return AesEncrypt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesECB\", function() { return AesECB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesCBC\", function() { return AesCBC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesCTR\", function() { return AesCTR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesGCM\", function() { return AesGCM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AesKW\", function() { return AesKW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RsaKeyGenParamsError\", function() { return RsaKeyGenParamsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RsaHashedImportParamsError\", function() { return RsaHashedImportParamsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rsa\", function() { return Rsa; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RsaSSA\", function() { return RsaSSA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RsaPSSParamsError\", function() { return RsaPSSParamsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RsaPSS\", function() { return RsaPSS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RsaOAEPParamsError\", function() { return RsaOAEPParamsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RsaOAEP\", function() { return RsaOAEP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EcKeyGenParamsError\", function() { return EcKeyGenParamsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ec\", function() { return Ec; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EcAlgorithmError\", function() { return EcAlgorithmError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdDSA\", function() { return EdDSA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EcDSA\", function() { return EcDSA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EcDH\", function() { return EcDH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaAlgorithms\", function() { return ShaAlgorithms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sha\", function() { return Sha; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n// Copyright (c) 2017, Peculiar Ventures, All rights reserved.\n\n\n\nfunction printf(text) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    var msg = text;\r\n    var regFind = /[^%](%\\d+)/g;\r\n    var match;\r\n    var matches = [];\r\n    while (match = regFind.exec(msg)) {\r\n        matches.push({ arg: match[1], index: match.index });\r\n    }\r\n    for (var i = matches.length - 1; i >= 0; i--) {\r\n        var item = matches[i];\r\n        var arg = item.arg.substring(1);\r\n        var index = item.index + 1;\r\n        msg = msg.substring(0, index) + arguments[+arg] + msg.substring(index + 1 + arg.length);\r\n    }\r\n    msg = msg.replace(\"%%\", \"%\");\r\n    return msg;\r\n}\r\nvar WebCryptoError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WebCryptoError, _super);\r\n    function WebCryptoError(template) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _this = _super.call(this) || this;\r\n        _this.code = 0;\r\n        _this.message = printf.apply(void 0, [template].concat(args));\r\n        var error = new Error(_this.message);\r\n        error.name = _this.constructor.name;\r\n        _this.stack = error.stack;\r\n        return _this;\r\n    }\r\n    WebCryptoError.NOT_SUPPORTED = \"Method is not supported\";\r\n    return WebCryptoError;\r\n}(Error));\r\nvar AlgorithmError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AlgorithmError, _super);\r\n    function AlgorithmError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 1;\r\n        return _this;\r\n    }\r\n    AlgorithmError.PARAM_REQUIRED = \"Algorithm hasn't got required paramter '%1'\";\r\n    AlgorithmError.PARAM_WRONG_TYPE = \"Algorithm has got wrong type for paramter '%1'. Must be %2\";\r\n    AlgorithmError.PARAM_WRONG_VALUE = \"Algorithm has got wrong value for paramter '%1'. Must be %2\";\r\n    AlgorithmError.WRONG_ALG_NAME = \"Algorithm has got wrong name '%1'. Must be '%2'\";\r\n    AlgorithmError.UNSUPPORTED_ALGORITHM = \"Algorithm '%1' is not supported\";\r\n    AlgorithmError.WRONG_USAGE = \"Algorithm doesn't support key usage '%1'\";\r\n    return AlgorithmError;\r\n}(WebCryptoError));\r\nvar CryptoKeyError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CryptoKeyError, _super);\r\n    function CryptoKeyError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 3;\r\n        return _this;\r\n    }\r\n    CryptoKeyError.EMPTY_KEY = \"CryptoKey is empty\";\r\n    CryptoKeyError.WRONG_KEY_ALG = \"CryptoKey has wrong algorithm '%1'. Must be '%2'\";\r\n    CryptoKeyError.WRONG_KEY_TYPE = \"CryptoKey has wrong type '%1'. Must be '%2'\";\r\n    CryptoKeyError.WRONG_KEY_USAGE = \"CryptoKey has wrong key usage. Must be '%1'\";\r\n    CryptoKeyError.NOT_EXTRACTABLE = \"CryptoKey is not extractable\";\r\n    CryptoKeyError.WRONG_FORMAT = \"CryptoKey has '%1' type. It can be used with '%2' format\";\r\n    CryptoKeyError.UNKNOWN_FORMAT = \"Unknown format in use '%1'. Must be one of 'raw', 'pkcs8', 'spki'  or 'jwk'\";\r\n    CryptoKeyError.ALLOWED_FORMAT = \"Wrong format value '%1'. Must be %2\";\r\n    return CryptoKeyError;\r\n}(WebCryptoError));\n\nfunction PrepareAlgorithm(alg) {\r\n    var res;\r\n    if (typeof alg === \"string\") {\r\n        res = { name: alg };\r\n    }\r\n    else {\r\n        res = alg;\r\n    }\r\n    BaseCrypto.checkAlgorithm(res);\r\n    var hashedAlg = alg;\r\n    if (hashedAlg.hash) {\r\n        hashedAlg.hash = PrepareAlgorithm(hashedAlg.hash);\r\n    }\r\n    return res;\r\n}\r\nfunction PrepareData(data, paramName) {\r\n    if (!data) {\r\n        throw new WebCryptoError(\"Parameter '\" + paramName + \"' is required and cant be empty\");\r\n    }\r\n    if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(data)) {\r\n        return new Uint8Array(data);\r\n    }\r\n    if (ArrayBuffer.isView(data)) {\r\n        var copy = data.map(function (i) { return i; });\r\n        return new Uint8Array(copy.buffer);\r\n    }\r\n    if (data instanceof ArrayBuffer) {\r\n        return new Uint8Array(data);\r\n    }\r\n    throw new WebCryptoError(\"Incoming parameter '\" + paramName + \"' has wrong data type. Must be ArrayBufferView or ArrayBuffer\");\r\n}\r\nvar BaseCrypto = (function () {\r\n    function BaseCrypto() {\r\n    }\r\n    BaseCrypto.checkAlgorithm = function (alg) {\r\n        if (typeof alg !== \"object\") {\r\n            throw new TypeError(\"Wrong algorithm data type. Must be Object\");\r\n        }\r\n        if (!alg.name) {\r\n            throw new AlgorithmError(AlgorithmError.PARAM_REQUIRED, \"name\");\r\n        }\r\n    };\r\n    BaseCrypto.checkAlgorithmParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n    };\r\n    BaseCrypto.checkKey = function (key, alg, type, usage) {\r\n        if (type === void 0) { type = null; }\r\n        if (usage === void 0) { usage = null; }\r\n        if (!key) {\r\n            throw new CryptoKeyError(CryptoKeyError.EMPTY_KEY);\r\n        }\r\n        var keyAlg = key.algorithm;\r\n        this.checkAlgorithm(keyAlg);\r\n        if (alg && (keyAlg.name.toUpperCase() !== alg.toUpperCase())) {\r\n            throw new CryptoKeyError(CryptoKeyError.WRONG_KEY_ALG, keyAlg.name, alg);\r\n        }\r\n        if (type && (!key.type || key.type.toUpperCase() !== type.toUpperCase())) {\r\n            throw new CryptoKeyError(CryptoKeyError.WRONG_KEY_TYPE, key.type, type);\r\n        }\r\n        if (usage) {\r\n            if (!key.usages.some(function (keyUsage) { return usage.toUpperCase() === keyUsage.toUpperCase(); })) {\r\n                throw new CryptoKeyError(CryptoKeyError.WRONG_KEY_USAGE, usage);\r\n            }\r\n        }\r\n    };\r\n    BaseCrypto.checkWrappedKey = function (key) {\r\n        if (!key.extractable) {\r\n            throw new CryptoKeyError(CryptoKeyError.NOT_EXTRACTABLE);\r\n        }\r\n    };\r\n    BaseCrypto.checkKeyUsages = function (keyUsages) {\r\n        if (!keyUsages || !keyUsages.length) {\r\n            throw new WebCryptoError(\"Parameter 'keyUsages' cannot be empty.\");\r\n        }\r\n    };\r\n    BaseCrypto.checkFormat = function (format, type) {\r\n        switch (format.toLowerCase()) {\r\n            case \"raw\":\r\n                if (type && type.toLowerCase() !== \"secret\" && type && type.toLowerCase() !== \"public\") {\r\n                    throw new CryptoKeyError(CryptoKeyError.WRONG_FORMAT, type, \"raw\");\r\n                }\r\n                break;\r\n            case \"pkcs8\":\r\n                if (type && type.toLowerCase() !== \"private\") {\r\n                    throw new CryptoKeyError(CryptoKeyError.WRONG_FORMAT, type, \"pkcs8\");\r\n                }\r\n                break;\r\n            case \"spki\":\r\n                if (type && type.toLowerCase() !== \"public\") {\r\n                    throw new CryptoKeyError(CryptoKeyError.WRONG_FORMAT, type, \"spki\");\r\n                }\r\n                break;\r\n            case \"jwk\":\r\n                break;\r\n            default:\r\n                throw new CryptoKeyError(CryptoKeyError.UNKNOWN_FORMAT, format);\r\n        }\r\n    };\r\n    BaseCrypto.generateKey = function (algorithm, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.digest = function (algorithm, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.sign = function (algorithm, key, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.verify = function (algorithm, key, signature, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.encrypt = function (algorithm, key, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.decrypt = function (algorithm, key, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.deriveBits = function (algorithm, baseKey, length) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.exportKey = function (format, key) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    BaseCrypto.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);\r\n        });\r\n    };\r\n    return BaseCrypto;\r\n}());\n\nvar AlgorithmNames = {\r\n    RsaSSA: \"RSASSA-PKCS1-v1_5\",\r\n    RsaPSS: \"RSA-PSS\",\r\n    RsaOAEP: \"RSA-OAEP\",\r\n    AesECB: \"AES-ECB\",\r\n    AesCTR: \"AES-CTR\",\r\n    AesCMAC: \"AES-CMAC\",\r\n    AesGCM: \"AES-GCM\",\r\n    AesCBC: \"AES-CBC\",\r\n    AesKW: \"AES-KW\",\r\n    Sha1: \"SHA-1\",\r\n    Sha256: \"SHA-256\",\r\n    Sha384: \"SHA-384\",\r\n    Sha512: \"SHA-512\",\r\n    ChaCha20: \"CHACHA20\",\r\n    EcDSA: \"ECDSA\",\r\n    EdDSA: \"EDDSA\",\r\n    EcDH: \"ECDH\",\r\n    Hmac: \"HMAC\",\r\n    Poly1305: \"POLY1305\",\r\n    Pbkdf2: \"PBKDF2\",\r\n};\n\nif (typeof self === \"undefined\") {\r\n    var g = global;\r\n    g.btoa = function (data) { return new Buffer(data, \"binary\").toString(\"base64\"); };\r\n    g.atob = function (data) { return new Buffer(data, \"base64\").toString(\"binary\"); };\r\n}\r\nvar Base64Url = (function () {\r\n    function Base64Url() {\r\n    }\r\n    Base64Url.encode = function (value) {\r\n        var str = this.buffer2string(value);\r\n        var res = btoa(str)\r\n            .replace(/=/g, \"\")\r\n            .replace(/\\+/g, \"-\")\r\n            .replace(/\\//g, \"_\");\r\n        return res;\r\n    };\r\n    Base64Url.decode = function (base64url) {\r\n        while (base64url.length % 4) {\r\n            base64url += \"=\";\r\n        }\r\n        var base64 = base64url\r\n            .replace(/\\-/g, \"+\")\r\n            .replace(/_/g, \"/\");\r\n        return this.string2buffer(atob(base64));\r\n    };\r\n    Base64Url.buffer2string = function (buffer) {\r\n        var res = \"\";\r\n        var len = buffer.length;\r\n        for (var i = 0; i < len; i++) {\r\n            res += String.fromCharCode(buffer[i]);\r\n        }\r\n        return res;\r\n    };\r\n    Base64Url.string2buffer = function (binaryString) {\r\n        var res = new Uint8Array(binaryString.length);\r\n        var len = binaryString.length;\r\n        for (var i = 0; i < len; i++) {\r\n            res[i] = binaryString.charCodeAt(i);\r\n        }\r\n        return res;\r\n    };\r\n    return Base64Url;\r\n}());\n\nvar AesKeyGenParamsError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesKeyGenParamsError, _super);\r\n    function AesKeyGenParamsError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 7;\r\n        return _this;\r\n    }\r\n    return AesKeyGenParamsError;\r\n}(AlgorithmError));\r\nvar Aes = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Aes, _super);\r\n    function Aes() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Aes.checkKeyUsages = function (keyUsages) {\r\n        var _this = this;\r\n        _super.checkKeyUsages.call(this, keyUsages);\r\n        var wrongUsage = keyUsages.filter(function (usage) { return _this.KEY_USAGES.indexOf(usage) === -1; });\r\n        if (wrongUsage.length) {\r\n            throw new AlgorithmError(AlgorithmError.WRONG_USAGE, wrongUsage.join(\", \"));\r\n        }\r\n    };\r\n    Aes.checkAlgorithm = function (alg) {\r\n        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase()) {\r\n            throw new AlgorithmError(AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);\r\n        }\r\n    };\r\n    Aes.checkKeyGenParams = function (alg) {\r\n        switch (alg.length) {\r\n            case 128:\r\n            case 192:\r\n            case 256:\r\n                break;\r\n            default:\r\n                throw new AesKeyGenParamsError(AesKeyGenParamsError.PARAM_WRONG_VALUE, \"length\", \"128, 192 or 256\");\r\n        }\r\n    };\r\n    Aes.generateKey = function (algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithm(algorithm);\r\n            _this.checkKeyGenParams(algorithm);\r\n            _this.checkKeyUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Aes.exportKey = function (format, key) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKey(key, _this.ALG_NAME);\r\n            _this.checkFormat(format, key.type);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Aes.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithm(algorithm);\r\n            _this.checkFormat(format);\r\n            if (!(format.toLowerCase() === \"raw\" || format.toLowerCase() === \"jwk\")) {\r\n                throw new CryptoKeyError(CryptoKeyError.ALLOWED_FORMAT, format, \"'jwk' or 'raw'\");\r\n            }\r\n            _this.checkKeyUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Aes.ALG_NAME = \"\";\r\n    Aes.KEY_USAGES = [];\r\n    return Aes;\r\n}(BaseCrypto));\r\nvar AesAlgorithmError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesAlgorithmError, _super);\r\n    function AesAlgorithmError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 8;\r\n        return _this;\r\n    }\r\n    return AesAlgorithmError;\r\n}(AlgorithmError));\r\nvar AesWrapKey = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesWrapKey, _super);\r\n    function AesWrapKey() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AesWrapKey.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(wrapAlgorithm);\r\n            _this.checkKey(wrappingKey, _this.ALG_NAME, \"secret\", \"wrapKey\");\r\n            _this.checkWrappedKey(key);\r\n            _this.checkFormat(format, key.type);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    AesWrapKey.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(unwrapAlgorithm);\r\n            _this.checkKey(unwrappingKey, _this.ALG_NAME, \"secret\", \"unwrapKey\");\r\n            _this.checkFormat(format);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    return AesWrapKey;\r\n}(Aes));\r\nvar AesEncrypt = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesEncrypt, _super);\r\n    function AesEncrypt() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AesEncrypt.encrypt = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"encrypt\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    AesEncrypt.decrypt = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"decrypt\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    AesEncrypt.KEY_USAGES = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\r\n    return AesEncrypt;\r\n}(AesWrapKey));\r\nvar AesECB = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesECB, _super);\r\n    function AesECB() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AesECB.ALG_NAME = AlgorithmNames.AesECB;\r\n    return AesECB;\r\n}(AesEncrypt));\r\nvar AesCBC = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesCBC, _super);\r\n    function AesCBC() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AesCBC.checkAlgorithmParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n        if (!alg.iv) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_REQUIRED, \"iv\");\r\n        }\r\n        if (!(ArrayBuffer.isView(alg.iv) || alg.iv instanceof ArrayBuffer)) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, \"iv\", \"ArrayBufferView or ArrayBuffer\");\r\n        }\r\n        if (alg.iv.byteLength !== 16) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, \"iv\", \"ArrayBufferView or ArrayBuffer with size 16\");\r\n        }\r\n    };\r\n    AesCBC.ALG_NAME = AlgorithmNames.AesCBC;\r\n    return AesCBC;\r\n}(AesEncrypt));\r\nvar AesCTR = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesCTR, _super);\r\n    function AesCTR() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AesCTR.checkAlgorithmParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n        if (!(alg.counter && (ArrayBuffer.isView(alg.counter) || alg.counter instanceof ArrayBuffer))) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, \"counter\", \"ArrayBufferView or ArrayBuffer\");\r\n        }\r\n        if (alg.counter.byteLength !== 16) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, \"counter\", \"ArrayBufferView or ArrayBuffer with size 16\");\r\n        }\r\n        if (!(alg.length > 0 && alg.length <= 128)) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, \"length\", \"number [1-128]\");\r\n        }\r\n    };\r\n    AesCTR.ALG_NAME = AlgorithmNames.AesCTR;\r\n    return AesCTR;\r\n}(AesEncrypt));\r\nvar AesGCM = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesGCM, _super);\r\n    function AesGCM() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AesGCM.checkAlgorithmParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n        if (alg.additionalData) {\r\n            if (!(ArrayBuffer.isView(alg.additionalData) || alg.additionalData instanceof ArrayBuffer)) {\r\n                throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, \"additionalData\", \"ArrayBufferView or ArrayBuffer\");\r\n            }\r\n        }\r\n        if (!alg.iv) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_REQUIRED, \"iv\");\r\n        }\r\n        if (!(ArrayBuffer.isView(alg.iv) || alg.iv instanceof ArrayBuffer)) {\r\n            throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_TYPE, \"iv\", \"ArrayBufferView or ArrayBuffer\");\r\n        }\r\n        if (alg.tagLength) {\r\n            var ok = [32, 64, 96, 104, 112, 120, 128].some(function (tagLength) {\r\n                return tagLength === alg.tagLength;\r\n            });\r\n            if (!ok) {\r\n                throw new AesAlgorithmError(AesAlgorithmError.PARAM_WRONG_VALUE, \"tagLength\", \"32, 64, 96, 104, 112, 120 or 128\");\r\n            }\r\n        }\r\n    };\r\n    AesGCM.ALG_NAME = AlgorithmNames.AesGCM;\r\n    return AesGCM;\r\n}(AesEncrypt));\r\nvar AesKW = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AesKW, _super);\r\n    function AesKW() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AesKW.checkAlgorithmParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n    };\r\n    AesKW.ALG_NAME = AlgorithmNames.AesKW;\r\n    AesKW.KEY_USAGES = [\"wrapKey\", \"unwrapKey\"];\r\n    return AesKW;\r\n}(AesWrapKey));\n\nvar ChaCha20 = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ChaCha20, _super);\r\n    function ChaCha20() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ChaCha20.encrypt = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"encrypt\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    ChaCha20.decrypt = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"decrypt\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    ChaCha20.checkKey = function (key, alg, type, usage) {\r\n        if (type === void 0) { type = null; }\r\n        if (usage === void 0) { usage = null; }\r\n        if (!key) {\r\n            throw new CryptoKeyError(CryptoKeyError.EMPTY_KEY);\r\n        }\r\n        if (type && (!key.type || key.type.toUpperCase() !== type.toUpperCase())) {\r\n            throw new CryptoKeyError(CryptoKeyError.WRONG_KEY_TYPE, key.type, type);\r\n        }\r\n        if (usage) {\r\n            if (!key.usages.some(function (keyUsage) { return usage.toUpperCase() === keyUsage.toUpperCase(); })) {\r\n                throw new CryptoKeyError(CryptoKeyError.WRONG_KEY_USAGE, usage);\r\n            }\r\n        }\r\n    };\r\n    ChaCha20.ALG_NAME = \"ChaCha20\";\r\n    ChaCha20.KEY_USAGES = [\"encrypt\", \"decrypt\"];\r\n    return ChaCha20;\r\n}(BaseCrypto));\n\nvar ShaAlgorithms = [AlgorithmNames.Sha1, AlgorithmNames.Sha256, AlgorithmNames.Sha384, AlgorithmNames.Sha512].join(\" | \");\r\nvar Sha = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Sha, _super);\r\n    function Sha() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Sha.checkAlgorithm = function (alg) {\r\n        var alg2;\r\n        if (typeof alg === \"string\") {\r\n            alg2 = { name: alg };\r\n        }\r\n        else {\r\n            alg2 = alg;\r\n        }\r\n        _super.checkAlgorithm.call(this, alg2);\r\n        switch (alg2.name.toUpperCase()) {\r\n            case AlgorithmNames.Sha1:\r\n            case AlgorithmNames.Sha256:\r\n            case AlgorithmNames.Sha384:\r\n            case AlgorithmNames.Sha512:\r\n                break;\r\n            default:\r\n                throw new AlgorithmError(AlgorithmError.WRONG_ALG_NAME, alg2.name, ShaAlgorithms);\r\n        }\r\n    };\r\n    Sha.digest = function (algorithm, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithm(algorithm);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    return Sha;\r\n}(BaseCrypto));\n\nvar EcKeyGenParamsError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EcKeyGenParamsError, _super);\r\n    function EcKeyGenParamsError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 9;\r\n        return _this;\r\n    }\r\n    return EcKeyGenParamsError;\r\n}(AlgorithmError));\r\nvar Ec = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Ec, _super);\r\n    function Ec() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Ec.checkAlgorithm = function (alg) {\r\n        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase()) {\r\n            throw new AlgorithmError(AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);\r\n        }\r\n    };\r\n    Ec.checkKeyGenParams = function (alg) {\r\n        var paramNamedCurve = \"namedCurve\";\r\n        if (!alg.namedCurve) {\r\n            throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_REQUIRED, paramNamedCurve);\r\n        }\r\n        if (!(typeof alg.namedCurve === \"string\")) {\r\n            throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_WRONG_TYPE, paramNamedCurve, \"string\");\r\n        }\r\n        switch (alg.namedCurve.toUpperCase()) {\r\n            case \"P-256\":\r\n            case \"K-256\":\r\n            case \"P-384\":\r\n            case \"P-521\":\r\n            case \"X25519\":\r\n            case \"ED25519\":\r\n                break;\r\n            default:\r\n                throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_WRONG_VALUE, paramNamedCurve, \"K-256, P-256, P-384, P-521, X25519 or ED25519\");\r\n        }\r\n    };\r\n    Ec.checkKeyGenUsages = function (keyUsages) {\r\n        var _this = this;\r\n        keyUsages.forEach(function (usage) {\r\n            var i = 0;\r\n            for (i; i < _this.KEY_USAGES.length; i++) {\r\n                if (_this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {\r\n                    break;\r\n                }\r\n            }\r\n            if (i === _this.KEY_USAGES.length) {\r\n                throw new WebCryptoError(\"Unsupported key usage '\" + usage + \"'. Should be one of [\" + _this.KEY_USAGES.join(\", \") + \"]\");\r\n            }\r\n        });\r\n    };\r\n    Ec.generateKey = function (algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithm(algorithm);\r\n            _this.checkKeyGenParams(algorithm);\r\n            _this.checkKeyGenUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Ec.exportKey = function (format, key) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKey(key, _this.ALG_NAME);\r\n            if (!(format && format.toLowerCase() === \"raw\" && key.type === \"public\")) {\r\n                _this.checkFormat(format, key.type);\r\n            }\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Ec.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKeyGenParams(algorithm);\r\n            _this.checkFormat(format);\r\n            _this.checkKeyGenUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Ec.ALG_NAME = \"\";\r\n    Ec.KEY_USAGES = [];\r\n    return Ec;\r\n}(BaseCrypto));\r\nvar EcAlgorithmError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EcAlgorithmError, _super);\r\n    function EcAlgorithmError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 10;\r\n        return _this;\r\n    }\r\n    return EcAlgorithmError;\r\n}(AlgorithmError));\r\nvar EdDSA = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EdDSA, _super);\r\n    function EdDSA() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    EdDSA.checkAlgorithmParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n        Sha.checkAlgorithm(alg.hash);\r\n    };\r\n    EdDSA.sign = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"private\", \"sign\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    EdDSA.verify = function (algorithm, key, signature, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"public\", \"verify\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    EdDSA.ALG_NAME = AlgorithmNames.EdDSA;\r\n    EdDSA.KEY_USAGES = [\"sign\", \"verify\"];\r\n    return EdDSA;\r\n}(Ec));\r\nvar EcDSA = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EcDSA, _super);\r\n    function EcDSA() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    EcDSA.checkAlgorithmParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n        Sha.checkAlgorithm(alg.hash);\r\n    };\r\n    EcDSA.sign = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"private\", \"sign\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    EcDSA.verify = function (algorithm, key, signature, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"public\", \"verify\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    EcDSA.ALG_NAME = AlgorithmNames.EcDSA;\r\n    EcDSA.KEY_USAGES = [\"sign\", \"verify\"];\r\n    return EcDSA;\r\n}(Ec));\r\nvar EcDH = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EcDH, _super);\r\n    function EcDH() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    EcDH.checkDeriveParams = function (algorithm) {\r\n        var paramPublic = \"public\";\r\n        this.checkAlgorithm(algorithm);\r\n        if (!algorithm.public) {\r\n            throw new EcAlgorithmError(EcAlgorithmError.PARAM_REQUIRED, paramPublic);\r\n        }\r\n        this.checkKey(algorithm.public, this.ALG_NAME, \"public\");\r\n    };\r\n    EcDH.deriveBits = function (algorithm, baseKey, length) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkDeriveParams(algorithm);\r\n            _this.checkKey(baseKey, _this.ALG_NAME, \"private\", \"deriveBits\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    EcDH.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkDeriveParams(algorithm);\r\n            _this.checkKey(baseKey, _this.ALG_NAME, \"private\", \"deriveKey\");\r\n            BaseCrypto.checkAlgorithm(derivedKeyType);\r\n            switch (derivedKeyType.name.toUpperCase()) {\r\n                case AlgorithmNames.AesCBC:\r\n                    AesCBC.checkKeyGenParams(derivedKeyType);\r\n                    break;\r\n                case AlgorithmNames.AesCTR:\r\n                    AesCTR.checkKeyGenParams(derivedKeyType);\r\n                    break;\r\n                case AlgorithmNames.AesGCM:\r\n                    AesGCM.checkKeyGenParams(derivedKeyType);\r\n                    break;\r\n                case AlgorithmNames.AesKW:\r\n                    AesKW.checkKeyGenParams(derivedKeyType);\r\n                    break;\r\n                default:\r\n                    throw new EcAlgorithmError(\"Unsupported name '\" + derivedKeyType.name + \"' for algorithm in param 'derivedKeyType'\");\r\n            }\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    EcDH.ALG_NAME = AlgorithmNames.EcDH;\r\n    EcDH.KEY_USAGES = [\"deriveKey\", \"deriveBits\"];\r\n    return EcDH;\r\n}(Ec));\n\nvar Hmac = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Hmac, _super);\r\n    function Hmac() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Hmac.checkAlgorithm = function (alg) {\r\n        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase()) {\r\n            throw new AlgorithmError(AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);\r\n        }\r\n    };\r\n    Hmac.checkKeyGenParams = function (alg) {\r\n        if (\"length\" in alg && !(alg.length > 0 && alg.length <= 512)) {\r\n            throw new AlgorithmError(AlgorithmError.PARAM_WRONG_VALUE, \"length\", \"more 0 and less than 512\");\r\n        }\r\n    };\r\n    Hmac.checkKeyGenUsages = function (keyUsages) {\r\n        var _this = this;\r\n        this.checkKeyUsages(keyUsages);\r\n        keyUsages.forEach(function (usage) {\r\n            var i = 0;\r\n            for (i; i < _this.KEY_USAGES.length; i++) {\r\n                if (_this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {\r\n                    break;\r\n                }\r\n            }\r\n            if (i === _this.KEY_USAGES.length) {\r\n                throw new WebCryptoError(\"Unsupported key usage '\" + usage + \"'. Should be one of [\" + _this.KEY_USAGES.join(\", \") + \"]\");\r\n            }\r\n        });\r\n    };\r\n    Hmac.generateKey = function (algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithm(algorithm);\r\n            _this.checkKeyGenParams(algorithm);\r\n            _this.checkKeyGenUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Hmac.exportKey = function (format, key) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKey(key, _this.ALG_NAME);\r\n            _this.checkFormat(format, key.type);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Hmac.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithm(algorithm);\r\n            _this.checkFormat(format);\r\n            if (!(format.toLowerCase() === \"raw\" || format.toLowerCase() === \"jwk\")) {\r\n                throw new CryptoKeyError(CryptoKeyError.ALLOWED_FORMAT, format, \"'jwk' or 'raw'\");\r\n            }\r\n            _this.checkKeyGenUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Hmac.sign = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"sign\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Hmac.verify = function (algorithm, key, signature, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"verify\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Hmac.ALG_NAME = AlgorithmNames.Hmac;\r\n    Hmac.KEY_USAGES = [\"sign\", \"verify\"];\r\n    return Hmac;\r\n}(BaseCrypto));\n\nvar Pbkdf2 = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Pbkdf2, _super);\r\n    function Pbkdf2() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Pbkdf2.checkAlgorithm = function (alg) {\r\n        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase()) {\r\n            throw new AlgorithmError(AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);\r\n        }\r\n    };\r\n    Pbkdf2.checkDeriveParams = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n        if (alg.salt) {\r\n            if (!(ArrayBuffer.isView(alg.salt) || alg.salt instanceof ArrayBuffer)) {\r\n                throw new AlgorithmError(AlgorithmError.PARAM_WRONG_TYPE, \"salt\", \"ArrayBuffer or ArrayBufferView\");\r\n            }\r\n        }\r\n        else {\r\n            throw new AlgorithmError(AlgorithmError.PARAM_REQUIRED, \"salt\");\r\n        }\r\n        if (!alg.iterations) {\r\n            throw new AlgorithmError(AlgorithmError.PARAM_REQUIRED, \"iterations\");\r\n        }\r\n        if (!alg.hash) {\r\n            throw new AlgorithmError(AlgorithmError.PARAM_REQUIRED, \"hash\");\r\n        }\r\n        var hash = PrepareAlgorithm(alg.hash);\r\n        Sha.checkAlgorithm(hash);\r\n    };\r\n    Pbkdf2.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return Promise.resolve()\r\n            .then(function () {\r\n            if (extractable) {\r\n                throw new WebCryptoError(\"KDF keys must set extractable=false\");\r\n            }\r\n            _this.checkAlgorithm(algorithm);\r\n            _this.checkFormat(format);\r\n            if (format.toLowerCase() !== \"raw\") {\r\n                throw new CryptoKeyError(CryptoKeyError.ALLOWED_FORMAT, format, \"'raw'\");\r\n            }\r\n            _this.checkKeyUsages(keyUsages);\r\n        });\r\n    };\r\n    Pbkdf2.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\r\n        var _this = this;\r\n        return Promise.resolve()\r\n            .then(function () {\r\n            _this.checkDeriveParams(algorithm);\r\n            _this.checkKey(baseKey, _this.ALG_NAME, \"secret\", \"deriveKey\");\r\n            BaseCrypto.checkAlgorithm(derivedKeyType);\r\n            switch (derivedKeyType.name.toUpperCase()) {\r\n                case AlgorithmNames.AesCBC:\r\n                    AesCBC.checkKeyGenParams(derivedKeyType);\r\n                    AesCBC.checkKeyUsages(keyUsages);\r\n                    break;\r\n                case AlgorithmNames.AesCTR:\r\n                    AesCTR.checkKeyGenParams(derivedKeyType);\r\n                    AesCTR.checkKeyUsages(keyUsages);\r\n                    break;\r\n                case AlgorithmNames.AesGCM:\r\n                    AesGCM.checkKeyGenParams(derivedKeyType);\r\n                    AesGCM.checkKeyUsages(keyUsages);\r\n                    break;\r\n                case AlgorithmNames.AesKW:\r\n                    AesKW.checkKeyGenParams(derivedKeyType);\r\n                    AesKW.checkKeyUsages(keyUsages);\r\n                    break;\r\n                case AlgorithmNames.Hmac:\r\n                    Hmac.checkKeyGenParams(derivedKeyType);\r\n                    Hmac.checkKeyUsages(keyUsages);\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, derivedKeyType);\r\n            }\r\n        });\r\n    };\r\n    Pbkdf2.deriveBits = function (algorithm, baseKey, length) {\r\n        var _this = this;\r\n        return Promise.resolve()\r\n            .then(function () {\r\n            _this.checkDeriveParams(algorithm);\r\n            _this.checkKey(baseKey, _this.ALG_NAME, \"secret\", \"deriveBits\");\r\n            if (!(length && typeof length === \"number\")) {\r\n                throw new WebCryptoError(\"Parameter 'length' must be Number and more than 0\");\r\n            }\r\n        });\r\n    };\r\n    Pbkdf2.ALG_NAME = AlgorithmNames.Pbkdf2;\r\n    Pbkdf2.KEY_USAGES = [\"deriveKey\", \"deriveBits\"];\r\n    return Pbkdf2;\r\n}(BaseCrypto));\n\nvar Poly1305 = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Poly1305, _super);\r\n    function Poly1305() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Poly1305.checkKeyGenUsages = function (keyUsages) {\r\n        var _this = this;\r\n        this.checkKeyUsages(keyUsages);\r\n        keyUsages.forEach(function (usage) {\r\n            var i = 0;\r\n            for (i; i < _this.KEY_USAGES.length; i++) {\r\n                if (_this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {\r\n                    break;\r\n                }\r\n            }\r\n            if (i === _this.KEY_USAGES.length) {\r\n                throw new WebCryptoError(\"Unsupported key usage '\" + usage + \"'. Should be one of [\" + _this.KEY_USAGES.join(\", \") + \"]\");\r\n            }\r\n        });\r\n    };\r\n    Poly1305.exportKey = function (format, key) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKey(key, _this.ALG_NAME);\r\n            _this.checkFormat(format, key.type);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Poly1305.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkFormat(format);\r\n            if (!(format.toLowerCase() === \"raw\" || format.toLowerCase() === \"jwk\")) {\r\n                throw new CryptoKeyError(CryptoKeyError.ALLOWED_FORMAT, format, \"'jwk' or 'raw'\");\r\n            }\r\n            _this.checkKeyGenUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Poly1305.sign = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"sign\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Poly1305.verify = function (algorithm, key, signature, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKey(key, _this.ALG_NAME, \"secret\", \"verify\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Poly1305.checkKey = function (key, alg, type, usage) {\r\n        if (type === void 0) { type = null; }\r\n        if (usage === void 0) { usage = null; }\r\n        if (!key) {\r\n            throw new CryptoKeyError(CryptoKeyError.EMPTY_KEY);\r\n        }\r\n        if (type && (!key.type || key.type.toUpperCase() !== type.toUpperCase())) {\r\n            throw new CryptoKeyError(CryptoKeyError.WRONG_KEY_TYPE, key.type, type);\r\n        }\r\n        if (usage) {\r\n            if (!key.usages.some(function (keyUsage) { return usage.toUpperCase() === keyUsage.toUpperCase(); })) {\r\n                throw new CryptoKeyError(CryptoKeyError.WRONG_KEY_USAGE, usage);\r\n            }\r\n        }\r\n    };\r\n    Poly1305.ALG_NAME = AlgorithmNames.Poly1305;\r\n    Poly1305.KEY_USAGES = [\"sign\", \"verify\"];\r\n    return Poly1305;\r\n}(BaseCrypto));\n\nvar RsaKeyGenParamsError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RsaKeyGenParamsError, _super);\r\n    function RsaKeyGenParamsError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 2;\r\n        return _this;\r\n    }\r\n    return RsaKeyGenParamsError;\r\n}(AlgorithmError));\r\nvar RsaHashedImportParamsError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RsaHashedImportParamsError, _super);\r\n    function RsaHashedImportParamsError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 6;\r\n        return _this;\r\n    }\r\n    return RsaHashedImportParamsError;\r\n}(AlgorithmError));\r\nvar Rsa = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Rsa, _super);\r\n    function Rsa() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Rsa.checkAlgorithm = function (alg) {\r\n        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase()) {\r\n            throw new AlgorithmError(AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);\r\n        }\r\n    };\r\n    Rsa.checkImportAlgorithm = function (alg) {\r\n        this.checkAlgorithm(alg);\r\n        if (!alg.hash) {\r\n            throw new RsaHashedImportParamsError(RsaHashedImportParamsError.PARAM_REQUIRED, \"hash\");\r\n        }\r\n        Sha.checkAlgorithm(alg.hash);\r\n    };\r\n    Rsa.checkKeyGenParams = function (alg) {\r\n        var modulusBits = alg.modulusLength;\r\n        if (!(modulusBits >= 256 && modulusBits <= 16384 && !(modulusBits % 8))) {\r\n            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_VALUE, \"modulusLength\", \" a multiple of 8 bits and >= 256 and <= 16384\");\r\n        }\r\n        var pubExp = alg.publicExponent;\r\n        if (!pubExp) {\r\n            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_REQUIRED, \"publicExponent\");\r\n        }\r\n        if (!ArrayBuffer.isView(pubExp)) {\r\n            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_TYPE, \"publicExponent\", \"ArrayBufferView\");\r\n        }\r\n        if (!(pubExp[0] === 3 || (pubExp[0] === 1 && pubExp[1] === 0 && pubExp[2] === 1))) {\r\n            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_VALUE, \"publicExponent\", \"Uint8Array([3]) | Uint8Array([1, 0, 1])\");\r\n        }\r\n        if (!alg.hash) {\r\n            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_REQUIRED, \"hash\", ShaAlgorithms);\r\n        }\r\n        Sha.checkAlgorithm(alg.hash);\r\n    };\r\n    Rsa.checkKeyGenUsages = function (keyUsages) {\r\n        var _this = this;\r\n        this.checkKeyUsages(keyUsages);\r\n        keyUsages.forEach(function (usage) {\r\n            var i = 0;\r\n            for (i; i < _this.KEY_USAGES.length; i++) {\r\n                if (_this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {\r\n                    break;\r\n                }\r\n            }\r\n            if (i === _this.KEY_USAGES.length) {\r\n                throw new WebCryptoError(\"Unsupported key usage '\" + usage + \"'. Should be one of [\" + _this.KEY_USAGES.join(\", \") + \"]\");\r\n            }\r\n        });\r\n    };\r\n    Rsa.generateKey = function (algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithm(algorithm);\r\n            _this.checkKeyGenParams(algorithm);\r\n            _this.checkKeyGenUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Rsa.exportKey = function (format, key) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkKey(key, _this.ALG_NAME);\r\n            _this.checkFormat(format, key.type);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Rsa.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkImportAlgorithm(algorithm);\r\n            _this.checkFormat(format);\r\n            if (format.toLowerCase() === \"raw\") {\r\n                throw new CryptoKeyError(CryptoKeyError.ALLOWED_FORMAT, format, \"'JsonWebKey', 'pkcs8' or 'spki'\");\r\n            }\r\n            _this.checkKeyGenUsages(keyUsages);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    Rsa.ALG_NAME = \"\";\r\n    Rsa.KEY_USAGES = [];\r\n    return Rsa;\r\n}(BaseCrypto));\r\nvar RsaSSA = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RsaSSA, _super);\r\n    function RsaSSA() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RsaSSA.sign = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"private\", \"sign\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    RsaSSA.verify = function (algorithm, key, signature, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"public\", \"verify\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    RsaSSA.ALG_NAME = AlgorithmNames.RsaSSA;\r\n    RsaSSA.KEY_USAGES = [\"sign\", \"verify\"];\r\n    return RsaSSA;\r\n}(Rsa));\r\nvar RsaPSSParamsError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RsaPSSParamsError, _super);\r\n    function RsaPSSParamsError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 4;\r\n        return _this;\r\n    }\r\n    return RsaPSSParamsError;\r\n}(AlgorithmError));\r\nvar RsaPSS = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RsaPSS, _super);\r\n    function RsaPSS() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RsaPSS.checkAlgorithmParams = function (algorithm) {\r\n        var alg = algorithm;\r\n        _super.checkAlgorithmParams.call(this, alg);\r\n        if (!alg.saltLength) {\r\n            throw new RsaPSSParamsError(RsaPSSParamsError.PARAM_REQUIRED, \"saltLength\");\r\n        }\r\n        if (alg.saltLength < 0) {\r\n            throw new RsaPSSParamsError(\"Parameter 'saltLength' is outside of numeric range\");\r\n        }\r\n    };\r\n    RsaPSS.ALG_NAME = AlgorithmNames.RsaPSS;\r\n    return RsaPSS;\r\n}(RsaSSA));\r\nvar RsaOAEPParamsError = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RsaOAEPParamsError, _super);\r\n    function RsaOAEPParamsError() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.code = 5;\r\n        return _this;\r\n    }\r\n    return RsaOAEPParamsError;\r\n}(AlgorithmError));\r\nvar RsaOAEP = (function (_super) {\r\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RsaOAEP, _super);\r\n    function RsaOAEP() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RsaOAEP.checkAlgorithmParams = function (alg) {\r\n        if (alg.label) {\r\n            if (!(ArrayBuffer.isView(alg.label) || alg.label instanceof ArrayBuffer)) {\r\n                throw new RsaOAEPParamsError(RsaOAEPParamsError.PARAM_WRONG_TYPE, \"label\", \"ArrayBufferView or ArrayBuffer\");\r\n            }\r\n        }\r\n    };\r\n    RsaOAEP.encrypt = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"public\", \"encrypt\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    RsaOAEP.decrypt = function (algorithm, key, data) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(algorithm);\r\n            _this.checkKey(key, _this.ALG_NAME, \"private\", \"decrypt\");\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    RsaOAEP.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(wrapAlgorithm);\r\n            _this.checkKey(wrappingKey, _this.ALG_NAME, \"public\", \"wrapKey\");\r\n            _this.checkWrappedKey(key);\r\n            _this.checkFormat(format, key.type);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    RsaOAEP.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.checkAlgorithmParams(unwrapAlgorithm);\r\n            _this.checkKey(unwrappingKey, _this.ALG_NAME, \"private\", \"unwrapKey\");\r\n            _this.checkFormat(format);\r\n            resolve(undefined);\r\n        });\r\n    };\r\n    RsaOAEP.ALG_NAME = AlgorithmNames.RsaOAEP;\r\n    RsaOAEP.KEY_USAGES = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\r\n    return RsaOAEP;\r\n}(Rsa));\n\nvar SubtleCrypto = (function () {\r\n    function SubtleCrypto() {\r\n    }\r\n    SubtleCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaSSA.toUpperCase():\r\n                    Class = RsaSSA;\r\n                    break;\r\n                case AlgorithmNames.RsaOAEP.toUpperCase():\r\n                    Class = RsaOAEP;\r\n                    break;\r\n                case AlgorithmNames.RsaPSS.toUpperCase():\r\n                    Class = RsaPSS;\r\n                    break;\r\n                case AlgorithmNames.AesECB.toUpperCase():\r\n                    Class = AesECB;\r\n                    break;\r\n                case AlgorithmNames.AesCBC.toUpperCase():\r\n                    Class = AesCBC;\r\n                    break;\r\n                case AlgorithmNames.AesCTR.toUpperCase():\r\n                    Class = AesCTR;\r\n                    break;\r\n                case AlgorithmNames.AesGCM.toUpperCase():\r\n                    Class = AesGCM;\r\n                    break;\r\n                case AlgorithmNames.AesKW.toUpperCase():\r\n                    Class = AesKW;\r\n                    break;\r\n                case AlgorithmNames.EcDSA.toUpperCase():\r\n                    Class = EcDSA;\r\n                    break;\r\n                case AlgorithmNames.EdDSA.toUpperCase():\r\n                    Class = EdDSA;\r\n                    break;\r\n                case AlgorithmNames.EcDH.toUpperCase():\r\n                    Class = EcDH;\r\n                    break;\r\n                case AlgorithmNames.Hmac.toUpperCase():\r\n                    Class = Hmac;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.generateKey(alg, extractable, keyUsages).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.digest = function (algorithm, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var buf = PrepareData(data, \"data\");\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.Sha1.toUpperCase():\r\n                case AlgorithmNames.Sha256.toUpperCase():\r\n                case AlgorithmNames.Sha384.toUpperCase():\r\n                case AlgorithmNames.Sha512.toUpperCase():\r\n                    Class = Sha;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.digest(alg, buf).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.sign = function (algorithm, key, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var buf = PrepareData(data, \"data\");\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaSSA.toUpperCase():\r\n                    Class = RsaSSA;\r\n                    break;\r\n                case AlgorithmNames.RsaPSS.toUpperCase():\r\n                    Class = RsaPSS;\r\n                    break;\r\n                case AlgorithmNames.EcDSA.toUpperCase():\r\n                    Class = EcDSA;\r\n                    break;\r\n                case AlgorithmNames.EdDSA.toUpperCase():\r\n                    Class = EdDSA;\r\n                    break;\r\n                case AlgorithmNames.Hmac.toUpperCase():\r\n                    Class = Hmac;\r\n                    break;\r\n                case AlgorithmNames.Poly1305.toUpperCase():\r\n                    Class = Poly1305;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.sign(alg, key, buf).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.verify = function (algorithm, key, signature, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var sigBuf = PrepareData(data, \"signature\");\r\n            var buf = PrepareData(data, \"data\");\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaSSA.toUpperCase():\r\n                    Class = RsaSSA;\r\n                    break;\r\n                case AlgorithmNames.RsaPSS.toUpperCase():\r\n                    Class = RsaPSS;\r\n                    break;\r\n                case AlgorithmNames.EcDSA.toUpperCase():\r\n                    Class = EcDSA;\r\n                    break;\r\n                case AlgorithmNames.EdDSA.toUpperCase():\r\n                    Class = EdDSA;\r\n                    break;\r\n                case AlgorithmNames.Hmac.toUpperCase():\r\n                    Class = Hmac;\r\n                    break;\r\n                case AlgorithmNames.Poly1305.toUpperCase():\r\n                    Class = Poly1305;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.verify(alg, key, sigBuf, buf).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.encrypt = function (algorithm, key, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var buf = PrepareData(data, \"data\");\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaOAEP.toUpperCase():\r\n                    Class = RsaOAEP;\r\n                    break;\r\n                case AlgorithmNames.AesECB.toUpperCase():\r\n                    Class = AesECB;\r\n                    break;\r\n                case AlgorithmNames.AesCBC.toUpperCase():\r\n                    Class = AesCBC;\r\n                    break;\r\n                case AlgorithmNames.AesCTR.toUpperCase():\r\n                    Class = AesCTR;\r\n                    break;\r\n                case AlgorithmNames.AesGCM.toUpperCase():\r\n                    Class = AesGCM;\r\n                    break;\r\n                case AlgorithmNames.ChaCha20.toUpperCase():\r\n                    Class = ChaCha20;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.encrypt(alg, key, buf).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.decrypt = function (algorithm, key, data) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var buf = PrepareData(data, \"data\");\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaOAEP.toUpperCase():\r\n                    Class = RsaOAEP;\r\n                    break;\r\n                case AlgorithmNames.AesECB.toUpperCase():\r\n                    Class = AesECB;\r\n                    break;\r\n                case AlgorithmNames.AesCBC.toUpperCase():\r\n                    Class = AesCBC;\r\n                    break;\r\n                case AlgorithmNames.AesCTR.toUpperCase():\r\n                    Class = AesCTR;\r\n                    break;\r\n                case AlgorithmNames.AesGCM.toUpperCase():\r\n                    Class = AesGCM;\r\n                    break;\r\n                case AlgorithmNames.ChaCha20.toUpperCase():\r\n                    Class = ChaCha20;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.decrypt(alg, key, buf).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.deriveBits = function (algorithm, baseKey, length) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.EcDH.toUpperCase():\r\n                    Class = EcDH;\r\n                    break;\r\n                case AlgorithmNames.Pbkdf2.toUpperCase():\r\n                    Class = Pbkdf2;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.deriveBits(alg, baseKey, length).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var derivedAlg = PrepareAlgorithm(derivedKeyType);\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.EcDH.toUpperCase():\r\n                    Class = EcDH;\r\n                    break;\r\n                case AlgorithmNames.Pbkdf2.toUpperCase():\r\n                    Class = Pbkdf2;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.deriveKey(alg, baseKey, derivedAlg, extractable, keyUsages).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.exportKey = function (format, key) {\r\n        return new Promise(function (resolve, reject) {\r\n            BaseCrypto.checkKey(key);\r\n            if (!key.extractable) {\r\n                throw new CryptoKeyError(CryptoKeyError.NOT_EXTRACTABLE);\r\n            }\r\n            var Class = BaseCrypto;\r\n            switch (key.algorithm.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaSSA.toUpperCase():\r\n                    Class = RsaSSA;\r\n                    break;\r\n                case AlgorithmNames.RsaPSS.toUpperCase():\r\n                    Class = RsaPSS;\r\n                    break;\r\n                case AlgorithmNames.AesECB.toUpperCase():\r\n                    Class = AesECB;\r\n                    break;\r\n                case AlgorithmNames.RsaOAEP.toUpperCase():\r\n                    Class = RsaOAEP;\r\n                    break;\r\n                case AlgorithmNames.AesCBC.toUpperCase():\r\n                    Class = AesCBC;\r\n                    break;\r\n                case AlgorithmNames.AesCTR.toUpperCase():\r\n                    Class = AesCTR;\r\n                    break;\r\n                case AlgorithmNames.AesGCM.toUpperCase():\r\n                    Class = AesGCM;\r\n                    break;\r\n                case AlgorithmNames.AesKW.toUpperCase():\r\n                    Class = AesKW;\r\n                    break;\r\n                case AlgorithmNames.EcDSA.toUpperCase():\r\n                    Class = EcDSA;\r\n                    break;\r\n                case AlgorithmNames.EdDSA.toUpperCase():\r\n                    Class = EdDSA;\r\n                    break;\r\n                case AlgorithmNames.EcDH.toUpperCase():\r\n                    Class = EcDH;\r\n                    break;\r\n                case AlgorithmNames.Hmac.toUpperCase():\r\n                    Class = Hmac;\r\n                    break;\r\n                case AlgorithmNames.Poly1305.toUpperCase():\r\n                    Class = Poly1305;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, key.algorithm.name);\r\n            }\r\n            Class.exportKey(format, key).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(algorithm);\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaSSA.toUpperCase():\r\n                    Class = RsaSSA;\r\n                    break;\r\n                case AlgorithmNames.RsaPSS.toUpperCase():\r\n                    Class = RsaPSS;\r\n                    break;\r\n                case AlgorithmNames.RsaOAEP.toUpperCase():\r\n                    Class = RsaOAEP;\r\n                    break;\r\n                case AlgorithmNames.AesECB.toUpperCase():\r\n                    Class = AesECB;\r\n                    break;\r\n                case AlgorithmNames.AesCBC.toUpperCase():\r\n                    Class = AesCBC;\r\n                    break;\r\n                case AlgorithmNames.AesCTR.toUpperCase():\r\n                    Class = AesCTR;\r\n                    break;\r\n                case AlgorithmNames.AesGCM.toUpperCase():\r\n                    Class = AesGCM;\r\n                    break;\r\n                case AlgorithmNames.AesKW.toUpperCase():\r\n                    Class = AesKW;\r\n                    break;\r\n                case AlgorithmNames.EcDSA.toUpperCase():\r\n                    Class = EcDSA;\r\n                    break;\r\n                case AlgorithmNames.EdDSA.toUpperCase():\r\n                    Class = EdDSA;\r\n                    break;\r\n                case AlgorithmNames.EcDH.toUpperCase():\r\n                    Class = EcDH;\r\n                    break;\r\n                case AlgorithmNames.Hmac.toUpperCase():\r\n                    Class = Hmac;\r\n                    break;\r\n                case AlgorithmNames.Pbkdf2.toUpperCase():\r\n                    Class = Pbkdf2;\r\n                    break;\r\n                case AlgorithmNames.Poly1305.toUpperCase():\r\n                    Class = Poly1305;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.importKey(format, keyData, alg, extractable, keyUsages).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {\r\n        return new Promise(function (resolve, reject) {\r\n            var alg = PrepareAlgorithm(wrapAlgorithm);\r\n            var Class = BaseCrypto;\r\n            switch (alg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaOAEP.toUpperCase():\r\n                    Class = RsaOAEP;\r\n                    break;\r\n                case AlgorithmNames.AesECB.toUpperCase():\r\n                    Class = AesECB;\r\n                    break;\r\n                case AlgorithmNames.AesCBC.toUpperCase():\r\n                    Class = AesCBC;\r\n                    break;\r\n                case AlgorithmNames.AesCTR.toUpperCase():\r\n                    Class = AesCTR;\r\n                    break;\r\n                case AlgorithmNames.AesGCM.toUpperCase():\r\n                    Class = AesGCM;\r\n                    break;\r\n                case AlgorithmNames.AesKW.toUpperCase():\r\n                    Class = AesKW;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\r\n            }\r\n            Class.wrapKey(format, key, wrappingKey, alg).then(resolve, reject);\r\n        });\r\n    };\r\n    SubtleCrypto.prototype.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\r\n        return new Promise(function (resolve, reject) {\r\n            var unwrapAlg = PrepareAlgorithm(unwrapAlgorithm);\r\n            var unwrappedAlg = PrepareAlgorithm(unwrappedKeyAlgorithm);\r\n            var buf = PrepareData(wrappedKey, \"wrappedKey\");\r\n            var Class = BaseCrypto;\r\n            switch (unwrapAlg.name.toUpperCase()) {\r\n                case AlgorithmNames.RsaOAEP.toUpperCase():\r\n                    Class = RsaOAEP;\r\n                    break;\r\n                case AlgorithmNames.AesECB.toUpperCase():\r\n                    Class = AesECB;\r\n                    break;\r\n                case AlgorithmNames.AesCBC.toUpperCase():\r\n                    Class = AesCBC;\r\n                    break;\r\n                case AlgorithmNames.AesCTR.toUpperCase():\r\n                    Class = AesCTR;\r\n                    break;\r\n                case AlgorithmNames.AesGCM.toUpperCase():\r\n                    Class = AesGCM;\r\n                    break;\r\n                case AlgorithmNames.AesKW.toUpperCase():\r\n                    Class = AesKW;\r\n                    break;\r\n                default:\r\n                    throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, unwrapAlg.name);\r\n            }\r\n            Class.unwrapKey(format, buf, unwrappingKey, unwrapAlg, unwrappedAlg, extractable, keyUsages).then(resolve, reject);\r\n        });\r\n    };\r\n    return SubtleCrypto;\r\n}());\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvZGlzdC93ZWJjcnlwdG8tY29yZS5lcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmVyLy4vbm9kZV9tb2R1bGVzL3dlYmNyeXB0by1jb3JlL2Rpc3Qvd2ViY3J5cHRvLWNvcmUuZXMuanM/ZjY1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcsIFBlY3VsaWFyIFZlbnR1cmVzLCBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5cbmZ1bmN0aW9uIHByaW50Zih0ZXh0KSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIG1zZyA9IHRleHQ7XHJcbiAgICB2YXIgcmVnRmluZCA9IC9bXiVdKCVcXGQrKS9nO1xyXG4gICAgdmFyIG1hdGNoO1xyXG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcclxuICAgIHdoaWxlIChtYXRjaCA9IHJlZ0ZpbmQuZXhlYyhtc2cpKSB7XHJcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHsgYXJnOiBtYXRjaFsxXSwgaW5kZXg6IG1hdGNoLmluZGV4IH0pO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IG1hdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB2YXIgaXRlbSA9IG1hdGNoZXNbaV07XHJcbiAgICAgICAgdmFyIGFyZyA9IGl0ZW0uYXJnLnN1YnN0cmluZygxKTtcclxuICAgICAgICB2YXIgaW5kZXggPSBpdGVtLmluZGV4ICsgMTtcclxuICAgICAgICBtc2cgPSBtc2cuc3Vic3RyaW5nKDAsIGluZGV4KSArIGFyZ3VtZW50c1srYXJnXSArIG1zZy5zdWJzdHJpbmcoaW5kZXggKyAxICsgYXJnLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBtc2cgPSBtc2cucmVwbGFjZShcIiUlXCIsIFwiJVwiKTtcclxuICAgIHJldHVybiBtc2c7XHJcbn1cclxudmFyIFdlYkNyeXB0b0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXZWJDcnlwdG9FcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFdlYkNyeXB0b0Vycm9yKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNvZGUgPSAwO1xyXG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBwcmludGYuYXBwbHkodm9pZCAwLCBbdGVtcGxhdGVdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKF90aGlzLm1lc3NhZ2UpO1xyXG4gICAgICAgIGVycm9yLm5hbWUgPSBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIF90aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgV2ViQ3J5cHRvRXJyb3IuTk9UX1NVUFBPUlRFRCA9IFwiTWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWRcIjtcclxuICAgIHJldHVybiBXZWJDcnlwdG9FcnJvcjtcclxufShFcnJvcikpO1xyXG52YXIgQWxnb3JpdGhtRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFsZ29yaXRobUVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWxnb3JpdGhtRXJyb3IoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29kZSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQWxnb3JpdGhtRXJyb3IuUEFSQU1fUkVRVUlSRUQgPSBcIkFsZ29yaXRobSBoYXNuJ3QgZ290IHJlcXVpcmVkIHBhcmFtdGVyICclMSdcIjtcclxuICAgIEFsZ29yaXRobUVycm9yLlBBUkFNX1dST05HX1RZUEUgPSBcIkFsZ29yaXRobSBoYXMgZ290IHdyb25nIHR5cGUgZm9yIHBhcmFtdGVyICclMScuIE11c3QgYmUgJTJcIjtcclxuICAgIEFsZ29yaXRobUVycm9yLlBBUkFNX1dST05HX1ZBTFVFID0gXCJBbGdvcml0aG0gaGFzIGdvdCB3cm9uZyB2YWx1ZSBmb3IgcGFyYW10ZXIgJyUxJy4gTXVzdCBiZSAlMlwiO1xyXG4gICAgQWxnb3JpdGhtRXJyb3IuV1JPTkdfQUxHX05BTUUgPSBcIkFsZ29yaXRobSBoYXMgZ290IHdyb25nIG5hbWUgJyUxJy4gTXVzdCBiZSAnJTInXCI7XHJcbiAgICBBbGdvcml0aG1FcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0gPSBcIkFsZ29yaXRobSAnJTEnIGlzIG5vdCBzdXBwb3J0ZWRcIjtcclxuICAgIEFsZ29yaXRobUVycm9yLldST05HX1VTQUdFID0gXCJBbGdvcml0aG0gZG9lc24ndCBzdXBwb3J0IGtleSB1c2FnZSAnJTEnXCI7XHJcbiAgICByZXR1cm4gQWxnb3JpdGhtRXJyb3I7XHJcbn0oV2ViQ3J5cHRvRXJyb3IpKTtcclxudmFyIENyeXB0b0tleUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDcnlwdG9LZXlFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENyeXB0b0tleUVycm9yKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNvZGUgPSAzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENyeXB0b0tleUVycm9yLkVNUFRZX0tFWSA9IFwiQ3J5cHRvS2V5IGlzIGVtcHR5XCI7XHJcbiAgICBDcnlwdG9LZXlFcnJvci5XUk9OR19LRVlfQUxHID0gXCJDcnlwdG9LZXkgaGFzIHdyb25nIGFsZ29yaXRobSAnJTEnLiBNdXN0IGJlICclMidcIjtcclxuICAgIENyeXB0b0tleUVycm9yLldST05HX0tFWV9UWVBFID0gXCJDcnlwdG9LZXkgaGFzIHdyb25nIHR5cGUgJyUxJy4gTXVzdCBiZSAnJTInXCI7XHJcbiAgICBDcnlwdG9LZXlFcnJvci5XUk9OR19LRVlfVVNBR0UgPSBcIkNyeXB0b0tleSBoYXMgd3Jvbmcga2V5IHVzYWdlLiBNdXN0IGJlICclMSdcIjtcclxuICAgIENyeXB0b0tleUVycm9yLk5PVF9FWFRSQUNUQUJMRSA9IFwiQ3J5cHRvS2V5IGlzIG5vdCBleHRyYWN0YWJsZVwiO1xyXG4gICAgQ3J5cHRvS2V5RXJyb3IuV1JPTkdfRk9STUFUID0gXCJDcnlwdG9LZXkgaGFzICclMScgdHlwZS4gSXQgY2FuIGJlIHVzZWQgd2l0aCAnJTInIGZvcm1hdFwiO1xyXG4gICAgQ3J5cHRvS2V5RXJyb3IuVU5LTk9XTl9GT1JNQVQgPSBcIlVua25vd24gZm9ybWF0IGluIHVzZSAnJTEnLiBNdXN0IGJlIG9uZSBvZiAncmF3JywgJ3BrY3M4JywgJ3Nwa2knICBvciAnandrJ1wiO1xyXG4gICAgQ3J5cHRvS2V5RXJyb3IuQUxMT1dFRF9GT1JNQVQgPSBcIldyb25nIGZvcm1hdCB2YWx1ZSAnJTEnLiBNdXN0IGJlICUyXCI7XHJcbiAgICByZXR1cm4gQ3J5cHRvS2V5RXJyb3I7XHJcbn0oV2ViQ3J5cHRvRXJyb3IpKTtcblxuZnVuY3Rpb24gUHJlcGFyZUFsZ29yaXRobShhbGcpIHtcclxuICAgIHZhciByZXM7XHJcbiAgICBpZiAodHlwZW9mIGFsZyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJlcyA9IHsgbmFtZTogYWxnIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXMgPSBhbGc7XHJcbiAgICB9XHJcbiAgICBCYXNlQ3J5cHRvLmNoZWNrQWxnb3JpdGhtKHJlcyk7XHJcbiAgICB2YXIgaGFzaGVkQWxnID0gYWxnO1xyXG4gICAgaWYgKGhhc2hlZEFsZy5oYXNoKSB7XHJcbiAgICAgICAgaGFzaGVkQWxnLmhhc2ggPSBQcmVwYXJlQWxnb3JpdGhtKGhhc2hlZEFsZy5oYXNoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gUHJlcGFyZURhdGEoZGF0YSwgcGFyYW1OYW1lKSB7XHJcbiAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoXCJQYXJhbWV0ZXIgJ1wiICsgcGFyYW1OYW1lICsgXCInIGlzIHJlcXVpcmVkIGFuZCBjYW50IGJlIGVtcHR5XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xyXG4gICAgICAgIHZhciBjb3B5ID0gZGF0YS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb3B5LmJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IFdlYkNyeXB0b0Vycm9yKFwiSW5jb21pbmcgcGFyYW1ldGVyICdcIiArIHBhcmFtTmFtZSArIFwiJyBoYXMgd3JvbmcgZGF0YSB0eXBlLiBNdXN0IGJlIEFycmF5QnVmZmVyVmlldyBvciBBcnJheUJ1ZmZlclwiKTtcclxufVxyXG52YXIgQmFzZUNyeXB0byA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCYXNlQ3J5cHRvKCkge1xyXG4gICAgfVxyXG4gICAgQmFzZUNyeXB0by5jaGVja0FsZ29yaXRobSA9IGZ1bmN0aW9uIChhbGcpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFsZyAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiV3JvbmcgYWxnb3JpdGhtIGRhdGEgdHlwZS4gTXVzdCBiZSBPYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxnLm5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlBBUkFNX1JFUVVJUkVELCBcIm5hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VDcnlwdG8uY2hlY2tBbGdvcml0aG1QYXJhbXMgPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobShhbGcpO1xyXG4gICAgfTtcclxuICAgIEJhc2VDcnlwdG8uY2hlY2tLZXkgPSBmdW5jdGlvbiAoa2V5LCBhbGcsIHR5cGUsIHVzYWdlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICh1c2FnZSA9PT0gdm9pZCAwKSB7IHVzYWdlID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5FTVBUWV9LRVkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5QWxnID0ga2V5LmFsZ29yaXRobTtcclxuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtKGtleUFsZyk7XHJcbiAgICAgICAgaWYgKGFsZyAmJiAoa2V5QWxnLm5hbWUudG9VcHBlckNhc2UoKSAhPT0gYWxnLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5XUk9OR19LRVlfQUxHLCBrZXlBbGcubmFtZSwgYWxnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgJiYgKCFrZXkudHlwZSB8fCBrZXkudHlwZS50b1VwcGVyQ2FzZSgpICE9PSB0eXBlLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5XUk9OR19LRVlfVFlQRSwga2V5LnR5cGUsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXNhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKCFrZXkudXNhZ2VzLnNvbWUoZnVuY3Rpb24gKGtleVVzYWdlKSB7IHJldHVybiB1c2FnZS50b1VwcGVyQ2FzZSgpID09PSBrZXlVc2FnZS50b1VwcGVyQ2FzZSgpOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLldST05HX0tFWV9VU0FHRSwgdXNhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VDcnlwdG8uY2hlY2tXcmFwcGVkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmICgha2V5LmV4dHJhY3RhYmxlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5OT1RfRVhUUkFDVEFCTEUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLmNoZWNrS2V5VXNhZ2VzID0gZnVuY3Rpb24gKGtleVVzYWdlcykge1xyXG4gICAgICAgIGlmICgha2V5VXNhZ2VzIHx8ICFrZXlVc2FnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDcnlwdG9FcnJvcihcIlBhcmFtZXRlciAna2V5VXNhZ2VzJyBjYW5ub3QgYmUgZW1wdHkuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLmNoZWNrRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCwgdHlwZSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBcInNlY3JldFwiICYmIHR5cGUgJiYgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBcInB1YmxpY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLldST05HX0ZPUk1BVCwgdHlwZSwgXCJyYXdcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IFwicHJpdmF0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLldST05HX0ZPUk1BVCwgdHlwZSwgXCJwa2NzOFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBcInB1YmxpY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLldST05HX0ZPUk1BVCwgdHlwZSwgXCJzcGtpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLlVOS05PV05fRk9STUFULCBmb3JtYXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLmdlbmVyYXRlS2V5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDcnlwdG9FcnJvcihXZWJDcnlwdG9FcnJvci5OT1RfU1VQUE9SVEVEKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLmRpZ2VzdCA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoV2ViQ3J5cHRvRXJyb3IuTk9UX1NVUFBPUlRFRCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZUNyeXB0by5zaWduID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNyeXB0b0Vycm9yKFdlYkNyeXB0b0Vycm9yLk5PVF9TVVBQT1JURUQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEJhc2VDcnlwdG8udmVyaWZ5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoV2ViQ3J5cHRvRXJyb3IuTk9UX1NVUFBPUlRFRCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZUNyeXB0by5lbmNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNyeXB0b0Vycm9yKFdlYkNyeXB0b0Vycm9yLk5PVF9TVVBQT1JURUQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEJhc2VDcnlwdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDcnlwdG9FcnJvcihXZWJDcnlwdG9FcnJvci5OT1RfU1VQUE9SVEVEKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLmRlcml2ZUJpdHMgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoV2ViQ3J5cHRvRXJyb3IuTk9UX1NVUFBPUlRFRCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZUNyeXB0by5kZXJpdmVLZXkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDcnlwdG9FcnJvcihXZWJDcnlwdG9FcnJvci5OT1RfU1VQUE9SVEVEKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLmV4cG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDcnlwdG9FcnJvcihXZWJDcnlwdG9FcnJvci5OT1RfU1VQUE9SVEVEKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLmltcG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDcnlwdG9FcnJvcihXZWJDcnlwdG9FcnJvci5OT1RfU1VQUE9SVEVEKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCYXNlQ3J5cHRvLndyYXBLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXksIHdyYXBwaW5nS2V5LCB3cmFwQWxnb3JpdGhtKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNyeXB0b0Vycm9yKFdlYkNyeXB0b0Vycm9yLk5PVF9TVVBQT1JURUQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEJhc2VDcnlwdG8udW53cmFwS2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwgd3JhcHBlZEtleSwgdW53cmFwcGluZ0tleSwgdW53cmFwQWxnb3JpdGhtLCB1bndyYXBwZWRLZXlBbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoV2ViQ3J5cHRvRXJyb3IuTk9UX1NVUFBPUlRFRCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhc2VDcnlwdG87XHJcbn0oKSk7XG5cbnZhciBBbGdvcml0aG1OYW1lcyA9IHtcclxuICAgIFJzYVNTQTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiLFxyXG4gICAgUnNhUFNTOiBcIlJTQS1QU1NcIixcclxuICAgIFJzYU9BRVA6IFwiUlNBLU9BRVBcIixcclxuICAgIEFlc0VDQjogXCJBRVMtRUNCXCIsXHJcbiAgICBBZXNDVFI6IFwiQUVTLUNUUlwiLFxyXG4gICAgQWVzQ01BQzogXCJBRVMtQ01BQ1wiLFxyXG4gICAgQWVzR0NNOiBcIkFFUy1HQ01cIixcclxuICAgIEFlc0NCQzogXCJBRVMtQ0JDXCIsXHJcbiAgICBBZXNLVzogXCJBRVMtS1dcIixcclxuICAgIFNoYTE6IFwiU0hBLTFcIixcclxuICAgIFNoYTI1NjogXCJTSEEtMjU2XCIsXHJcbiAgICBTaGEzODQ6IFwiU0hBLTM4NFwiLFxyXG4gICAgU2hhNTEyOiBcIlNIQS01MTJcIixcclxuICAgIENoYUNoYTIwOiBcIkNIQUNIQTIwXCIsXHJcbiAgICBFY0RTQTogXCJFQ0RTQVwiLFxyXG4gICAgRWREU0E6IFwiRUREU0FcIixcclxuICAgIEVjREg6IFwiRUNESFwiLFxyXG4gICAgSG1hYzogXCJITUFDXCIsXHJcbiAgICBQb2x5MTMwNTogXCJQT0xZMTMwNVwiLFxyXG4gICAgUGJrZGYyOiBcIlBCS0RGMlwiLFxyXG59O1xuXG5pZiAodHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHZhciBnID0gZ2xvYmFsO1xyXG4gICAgZy5idG9hID0gZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSwgXCJiaW5hcnlcIikudG9TdHJpbmcoXCJiYXNlNjRcIik7IH07XHJcbiAgICBnLmF0b2IgPSBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbmV3IEJ1ZmZlcihkYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZyhcImJpbmFyeVwiKTsgfTtcclxufVxyXG52YXIgQmFzZTY0VXJsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2U2NFVybCgpIHtcclxuICAgIH1cclxuICAgIEJhc2U2NFVybC5lbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5idWZmZXIyc3RyaW5nKHZhbHVlKTtcclxuICAgICAgICB2YXIgcmVzID0gYnRvYShzdHIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC89L2csIFwiXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgQmFzZTY0VXJsLmRlY29kZSA9IGZ1bmN0aW9uIChiYXNlNjR1cmwpIHtcclxuICAgICAgICB3aGlsZSAoYmFzZTY0dXJsLmxlbmd0aCAlIDQpIHtcclxuICAgICAgICAgICAgYmFzZTY0dXJsICs9IFwiPVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZTY0ID0gYmFzZTY0dXJsXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC0vZywgXCIrXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcyYnVmZmVyKGF0b2IoYmFzZTY0KSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZTY0VXJsLmJ1ZmZlcjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IFwiXCI7XHJcbiAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIEJhc2U2NFVybC5zdHJpbmcyYnVmZmVyID0gZnVuY3Rpb24gKGJpbmFyeVN0cmluZykge1xyXG4gICAgICAgIHZhciByZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcclxuICAgICAgICB2YXIgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCYXNlNjRVcmw7XHJcbn0oKSk7XG5cbnZhciBBZXNLZXlHZW5QYXJhbXNFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWVzS2V5R2VuUGFyYW1zRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZXNLZXlHZW5QYXJhbXNFcnJvcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jb2RlID0gNztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQWVzS2V5R2VuUGFyYW1zRXJyb3I7XHJcbn0oQWxnb3JpdGhtRXJyb3IpKTtcclxudmFyIEFlcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWVzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWVzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEFlcy5jaGVja0tleVVzYWdlcyA9IGZ1bmN0aW9uIChrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9zdXBlci5jaGVja0tleVVzYWdlcy5jYWxsKHRoaXMsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgdmFyIHdyb25nVXNhZ2UgPSBrZXlVc2FnZXMuZmlsdGVyKGZ1bmN0aW9uICh1c2FnZSkgeyByZXR1cm4gX3RoaXMuS0VZX1VTQUdFUy5pbmRleE9mKHVzYWdlKSA9PT0gLTE7IH0pO1xyXG4gICAgICAgIGlmICh3cm9uZ1VzYWdlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuV1JPTkdfVVNBR0UsIHdyb25nVXNhZ2Uuam9pbihcIiwgXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWVzLmNoZWNrQWxnb3JpdGhtID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIGlmIChhbGcubmFtZS50b1VwcGVyQ2FzZSgpICE9PSB0aGlzLkFMR19OQU1FLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLldST05HX0FMR19OQU1FLCBhbGcubmFtZSwgdGhpcy5BTEdfTkFNRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFlcy5jaGVja0tleUdlblBhcmFtcyA9IGZ1bmN0aW9uIChhbGcpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAxMjg6XHJcbiAgICAgICAgICAgIGNhc2UgMTkyOlxyXG4gICAgICAgICAgICBjYXNlIDI1NjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFlc0tleUdlblBhcmFtc0Vycm9yKEFlc0tleUdlblBhcmFtc0Vycm9yLlBBUkFNX1dST05HX1ZBTFVFLCBcImxlbmd0aFwiLCBcIjEyOCwgMTkyIG9yIDI1NlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWVzLmdlbmVyYXRlS2V5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXlHZW5QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFlcy5leHBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5KGtleSwgX3RoaXMuQUxHX05BTUUpO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0Zvcm1hdChmb3JtYXQsIGtleS50eXBlKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFlcy5pbXBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrRm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgICAgIGlmICghKGZvcm1hdC50b0xvd2VyQ2FzZSgpID09PSBcInJhd1wiIHx8IGZvcm1hdC50b0xvd2VyQ2FzZSgpID09PSBcImp3a1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLkFMTE9XRURfRk9STUFULCBmb3JtYXQsIFwiJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFlcy5BTEdfTkFNRSA9IFwiXCI7XHJcbiAgICBBZXMuS0VZX1VTQUdFUyA9IFtdO1xyXG4gICAgcmV0dXJuIEFlcztcclxufShCYXNlQ3J5cHRvKSk7XHJcbnZhciBBZXNBbGdvcml0aG1FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWVzQWxnb3JpdGhtRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZXNBbGdvcml0aG1FcnJvcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jb2RlID0gODtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQWVzQWxnb3JpdGhtRXJyb3I7XHJcbn0oQWxnb3JpdGhtRXJyb3IpKTtcclxudmFyIEFlc1dyYXBLZXkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFlc1dyYXBLZXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZXNXcmFwS2V5KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEFlc1dyYXBLZXkud3JhcEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleSwgd3JhcHBpbmdLZXksIHdyYXBBbGdvcml0aG0pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKHdyYXBBbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleSh3cmFwcGluZ0tleSwgX3RoaXMuQUxHX05BTUUsIFwic2VjcmV0XCIsIFwid3JhcEtleVwiKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tXcmFwcGVkS2V5KGtleSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrRm9ybWF0KGZvcm1hdCwga2V5LnR5cGUpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWVzV3JhcEtleS51bndyYXBLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCB3cmFwcGVkS2V5LCB1bndyYXBwaW5nS2V5LCB1bndyYXBBbGdvcml0aG0sIHVud3JhcHBlZEtleUFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXModW53cmFwQWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkodW53cmFwcGluZ0tleSwgX3RoaXMuQUxHX05BTUUsIFwic2VjcmV0XCIsIFwidW53cmFwS2V5XCIpO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0Zvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFlc1dyYXBLZXk7XHJcbn0oQWVzKSk7XHJcbnZhciBBZXNFbmNyeXB0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBZXNFbmNyeXB0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWVzRW5jcnlwdCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBBZXNFbmNyeXB0LmVuY3J5cHQgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5KGtleSwgX3RoaXMuQUxHX05BTUUsIFwic2VjcmV0XCIsIFwiZW5jcnlwdFwiKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFlc0VuY3J5cHQuZGVjcnlwdCA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJzZWNyZXRcIiwgXCJkZWNyeXB0XCIpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWVzRW5jcnlwdC5LRVlfVVNBR0VTID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xyXG4gICAgcmV0dXJuIEFlc0VuY3J5cHQ7XHJcbn0oQWVzV3JhcEtleSkpO1xyXG52YXIgQWVzRUNCID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBZXNFQ0IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZXNFQ0IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQWVzRUNCLkFMR19OQU1FID0gQWxnb3JpdGhtTmFtZXMuQWVzRUNCO1xyXG4gICAgcmV0dXJuIEFlc0VDQjtcclxufShBZXNFbmNyeXB0KSk7XHJcbnZhciBBZXNDQkMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFlc0NCQywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFlc0NCQygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBBZXNDQkMuY2hlY2tBbGdvcml0aG1QYXJhbXMgPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobShhbGcpO1xyXG4gICAgICAgIGlmICghYWxnLml2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBZXNBbGdvcml0aG1FcnJvcihBZXNBbGdvcml0aG1FcnJvci5QQVJBTV9SRVFVSVJFRCwgXCJpdlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoQXJyYXlCdWZmZXIuaXNWaWV3KGFsZy5pdikgfHwgYWxnLml2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBZXNBbGdvcml0aG1FcnJvcihBZXNBbGdvcml0aG1FcnJvci5QQVJBTV9XUk9OR19UWVBFLCBcIml2XCIsIFwiQXJyYXlCdWZmZXJWaWV3IG9yIEFycmF5QnVmZmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxnLml2LmJ5dGVMZW5ndGggIT09IDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBZXNBbGdvcml0aG1FcnJvcihBZXNBbGdvcml0aG1FcnJvci5QQVJBTV9XUk9OR19WQUxVRSwgXCJpdlwiLCBcIkFycmF5QnVmZmVyVmlldyBvciBBcnJheUJ1ZmZlciB3aXRoIHNpemUgMTZcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFlc0NCQy5BTEdfTkFNRSA9IEFsZ29yaXRobU5hbWVzLkFlc0NCQztcclxuICAgIHJldHVybiBBZXNDQkM7XHJcbn0oQWVzRW5jcnlwdCkpO1xyXG52YXIgQWVzQ1RSID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBZXNDVFIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZXNDVFIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQWVzQ1RSLmNoZWNrQWxnb3JpdGhtUGFyYW1zID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG0oYWxnKTtcclxuICAgICAgICBpZiAoIShhbGcuY291bnRlciAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KGFsZy5jb3VudGVyKSB8fCBhbGcuY291bnRlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFlc0FsZ29yaXRobUVycm9yKEFlc0FsZ29yaXRobUVycm9yLlBBUkFNX1dST05HX1RZUEUsIFwiY291bnRlclwiLCBcIkFycmF5QnVmZmVyVmlldyBvciBBcnJheUJ1ZmZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsZy5jb3VudGVyLmJ5dGVMZW5ndGggIT09IDE2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBZXNBbGdvcml0aG1FcnJvcihBZXNBbGdvcml0aG1FcnJvci5QQVJBTV9XUk9OR19WQUxVRSwgXCJjb3VudGVyXCIsIFwiQXJyYXlCdWZmZXJWaWV3IG9yIEFycmF5QnVmZmVyIHdpdGggc2l6ZSAxNlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoYWxnLmxlbmd0aCA+IDAgJiYgYWxnLmxlbmd0aCA8PSAxMjgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBZXNBbGdvcml0aG1FcnJvcihBZXNBbGdvcml0aG1FcnJvci5QQVJBTV9XUk9OR19WQUxVRSwgXCJsZW5ndGhcIiwgXCJudW1iZXIgWzEtMTI4XVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWVzQ1RSLkFMR19OQU1FID0gQWxnb3JpdGhtTmFtZXMuQWVzQ1RSO1xyXG4gICAgcmV0dXJuIEFlc0NUUjtcclxufShBZXNFbmNyeXB0KSk7XHJcbnZhciBBZXNHQ00gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFlc0dDTSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFlc0dDTSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBBZXNHQ00uY2hlY2tBbGdvcml0aG1QYXJhbXMgPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobShhbGcpO1xyXG4gICAgICAgIGlmIChhbGcuYWRkaXRpb25hbERhdGEpIHtcclxuICAgICAgICAgICAgaWYgKCEoQXJyYXlCdWZmZXIuaXNWaWV3KGFsZy5hZGRpdGlvbmFsRGF0YSkgfHwgYWxnLmFkZGl0aW9uYWxEYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWVzQWxnb3JpdGhtRXJyb3IoQWVzQWxnb3JpdGhtRXJyb3IuUEFSQU1fV1JPTkdfVFlQRSwgXCJhZGRpdGlvbmFsRGF0YVwiLCBcIkFycmF5QnVmZmVyVmlldyBvciBBcnJheUJ1ZmZlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFsZy5pdikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWVzQWxnb3JpdGhtRXJyb3IoQWVzQWxnb3JpdGhtRXJyb3IuUEFSQU1fUkVRVUlSRUQsIFwiaXZcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKEFycmF5QnVmZmVyLmlzVmlldyhhbGcuaXYpIHx8IGFsZy5pdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWVzQWxnb3JpdGhtRXJyb3IoQWVzQWxnb3JpdGhtRXJyb3IuUEFSQU1fV1JPTkdfVFlQRSwgXCJpdlwiLCBcIkFycmF5QnVmZmVyVmlldyBvciBBcnJheUJ1ZmZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsZy50YWdMZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIG9rID0gWzMyLCA2NCwgOTYsIDEwNCwgMTEyLCAxMjAsIDEyOF0uc29tZShmdW5jdGlvbiAodGFnTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnTGVuZ3RoID09PSBhbGcudGFnTGVuZ3RoO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFvaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFlc0FsZ29yaXRobUVycm9yKEFlc0FsZ29yaXRobUVycm9yLlBBUkFNX1dST05HX1ZBTFVFLCBcInRhZ0xlbmd0aFwiLCBcIjMyLCA2NCwgOTYsIDEwNCwgMTEyLCAxMjAgb3IgMTI4XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFlc0dDTS5BTEdfTkFNRSA9IEFsZ29yaXRobU5hbWVzLkFlc0dDTTtcclxuICAgIHJldHVybiBBZXNHQ007XHJcbn0oQWVzRW5jcnlwdCkpO1xyXG52YXIgQWVzS1cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFlc0tXLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWVzS1coKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQWVzS1cuY2hlY2tBbGdvcml0aG1QYXJhbXMgPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobShhbGcpO1xyXG4gICAgfTtcclxuICAgIEFlc0tXLkFMR19OQU1FID0gQWxnb3JpdGhtTmFtZXMuQWVzS1c7XHJcbiAgICBBZXNLVy5LRVlfVVNBR0VTID0gW1wid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcclxuICAgIHJldHVybiBBZXNLVztcclxufShBZXNXcmFwS2V5KSk7XG5cbnZhciBDaGFDaGEyMCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2hhQ2hhMjAsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDaGFDaGEyMCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBDaGFDaGEyMC5lbmNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleShrZXksIF90aGlzLkFMR19OQU1FLCBcInNlY3JldFwiLCBcImVuY3J5cHRcIik7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDaGFDaGEyMC5kZWNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleShrZXksIF90aGlzLkFMR19OQU1FLCBcInNlY3JldFwiLCBcImRlY3J5cHRcIik7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDaGFDaGEyMC5jaGVja0tleSA9IGZ1bmN0aW9uIChrZXksIGFsZywgdHlwZSwgdXNhZ2UpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHVzYWdlID09PSB2b2lkIDApIHsgdXNhZ2UgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKCFrZXkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLkVNUFRZX0tFWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlICYmICgha2V5LnR5cGUgfHwga2V5LnR5cGUudG9VcHBlckNhc2UoKSAhPT0gdHlwZS50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvS2V5RXJyb3IoQ3J5cHRvS2V5RXJyb3IuV1JPTkdfS0VZX1RZUEUsIGtleS50eXBlLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICgha2V5LnVzYWdlcy5zb21lKGZ1bmN0aW9uIChrZXlVc2FnZSkgeyByZXR1cm4gdXNhZ2UudG9VcHBlckNhc2UoKSA9PT0ga2V5VXNhZ2UudG9VcHBlckNhc2UoKTsgfSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5XUk9OR19LRVlfVVNBR0UsIHVzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaGFDaGEyMC5BTEdfTkFNRSA9IFwiQ2hhQ2hhMjBcIjtcclxuICAgIENoYUNoYTIwLktFWV9VU0FHRVMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXTtcclxuICAgIHJldHVybiBDaGFDaGEyMDtcclxufShCYXNlQ3J5cHRvKSk7XG5cbnZhciBTaGFBbGdvcml0aG1zID0gW0FsZ29yaXRobU5hbWVzLlNoYTEsIEFsZ29yaXRobU5hbWVzLlNoYTI1NiwgQWxnb3JpdGhtTmFtZXMuU2hhMzg0LCBBbGdvcml0aG1OYW1lcy5TaGE1MTJdLmpvaW4oXCIgfCBcIik7XHJcbnZhciBTaGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNoYSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNoYSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBTaGEuY2hlY2tBbGdvcml0aG0gPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgdmFyIGFsZzI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhbGcgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgYWxnMiA9IHsgbmFtZTogYWxnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhbGcyID0gYWxnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIuY2hlY2tBbGdvcml0aG0uY2FsbCh0aGlzLCBhbGcyKTtcclxuICAgICAgICBzd2l0Y2ggKGFsZzIubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuU2hhMTpcclxuICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5TaGEyNTY6XHJcbiAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuU2hhMzg0OlxyXG4gICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlNoYTUxMjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLldST05HX0FMR19OQU1FLCBhbGcyLm5hbWUsIFNoYUFsZ29yaXRobXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaGEuZGlnZXN0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaGE7XHJcbn0oQmFzZUNyeXB0bykpO1xuXG52YXIgRWNLZXlHZW5QYXJhbXNFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRWNLZXlHZW5QYXJhbXNFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVjS2V5R2VuUGFyYW1zRXJyb3IoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29kZSA9IDk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEVjS2V5R2VuUGFyYW1zRXJyb3I7XHJcbn0oQWxnb3JpdGhtRXJyb3IpKTtcclxudmFyIEVjID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVjKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEVjLmNoZWNrQWxnb3JpdGhtID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIGlmIChhbGcubmFtZS50b1VwcGVyQ2FzZSgpICE9PSB0aGlzLkFMR19OQU1FLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLldST05HX0FMR19OQU1FLCBhbGcubmFtZSwgdGhpcy5BTEdfTkFNRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVjLmNoZWNrS2V5R2VuUGFyYW1zID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIHZhciBwYXJhbU5hbWVkQ3VydmUgPSBcIm5hbWVkQ3VydmVcIjtcclxuICAgICAgICBpZiAoIWFsZy5uYW1lZEN1cnZlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFY0tleUdlblBhcmFtc0Vycm9yKEVjS2V5R2VuUGFyYW1zRXJyb3IuUEFSQU1fUkVRVUlSRUQsIHBhcmFtTmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHR5cGVvZiBhbGcubmFtZWRDdXJ2ZSA9PT0gXCJzdHJpbmdcIikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVjS2V5R2VuUGFyYW1zRXJyb3IoRWNLZXlHZW5QYXJhbXNFcnJvci5QQVJBTV9XUk9OR19UWVBFLCBwYXJhbU5hbWVkQ3VydmUsIFwic3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lZEN1cnZlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlAtMjU2XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJLLTI1NlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUC0zODRcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlAtNTIxXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJYMjU1MTlcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkVEMjU1MTlcIjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVjS2V5R2VuUGFyYW1zRXJyb3IoRWNLZXlHZW5QYXJhbXNFcnJvci5QQVJBTV9XUk9OR19WQUxVRSwgcGFyYW1OYW1lZEN1cnZlLCBcIkstMjU2LCBQLTI1NiwgUC0zODQsIFAtNTIxLCBYMjU1MTkgb3IgRUQyNTUxOVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRWMuY2hlY2tLZXlHZW5Vc2FnZXMgPSBmdW5jdGlvbiAoa2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBrZXlVc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAodXNhZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBfdGhpcy5LRVlfVVNBR0VTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuS0VZX1VTQUdFU1tpXS50b0xvd2VyQ2FzZSgpID09PSB1c2FnZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IF90aGlzLktFWV9VU0FHRVMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoXCJVbnN1cHBvcnRlZCBrZXkgdXNhZ2UgJ1wiICsgdXNhZ2UgKyBcIicuIFNob3VsZCBiZSBvbmUgb2YgW1wiICsgX3RoaXMuS0VZX1VTQUdFUy5qb2luKFwiLCBcIikgKyBcIl1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFYy5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5R2VuUGFyYW1zKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5R2VuVXNhZ2VzKGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFYy5leHBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5KGtleSwgX3RoaXMuQUxHX05BTUUpO1xyXG4gICAgICAgICAgICBpZiAoIShmb3JtYXQgJiYgZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwicmF3XCIgJiYga2V5LnR5cGUgPT09IFwicHVibGljXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGVja0Zvcm1hdChmb3JtYXQsIGtleS50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRWMuaW1wb3J0S2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleUdlblBhcmFtcyhhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0Zvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleUdlblVzYWdlcyhrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRWMuQUxHX05BTUUgPSBcIlwiO1xyXG4gICAgRWMuS0VZX1VTQUdFUyA9IFtdO1xyXG4gICAgcmV0dXJuIEVjO1xyXG59KEJhc2VDcnlwdG8pKTtcclxudmFyIEVjQWxnb3JpdGhtRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVjQWxnb3JpdGhtRXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFY0FsZ29yaXRobUVycm9yKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNvZGUgPSAxMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRWNBbGdvcml0aG1FcnJvcjtcclxufShBbGdvcml0aG1FcnJvcikpO1xyXG52YXIgRWREU0EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVkRFNBLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRWREU0EoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRWREU0EuY2hlY2tBbGdvcml0aG1QYXJhbXMgPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobShhbGcpO1xyXG4gICAgICAgIFNoYS5jaGVja0FsZ29yaXRobShhbGcuaGFzaCk7XHJcbiAgICB9O1xyXG4gICAgRWREU0Euc2lnbiA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwcml2YXRlXCIsIFwic2lnblwiKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVkRFNBLnZlcmlmeSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleShrZXksIF90aGlzLkFMR19OQU1FLCBcInB1YmxpY1wiLCBcInZlcmlmeVwiKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVkRFNBLkFMR19OQU1FID0gQWxnb3JpdGhtTmFtZXMuRWREU0E7XHJcbiAgICBFZERTQS5LRVlfVVNBR0VTID0gW1wic2lnblwiLCBcInZlcmlmeVwiXTtcclxuICAgIHJldHVybiBFZERTQTtcclxufShFYykpO1xyXG52YXIgRWNEU0EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVjRFNBLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRWNEU0EoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRWNEU0EuY2hlY2tBbGdvcml0aG1QYXJhbXMgPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobShhbGcpO1xyXG4gICAgICAgIFNoYS5jaGVja0FsZ29yaXRobShhbGcuaGFzaCk7XHJcbiAgICB9O1xyXG4gICAgRWNEU0Euc2lnbiA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwcml2YXRlXCIsIFwic2lnblwiKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVjRFNBLnZlcmlmeSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleShrZXksIF90aGlzLkFMR19OQU1FLCBcInB1YmxpY1wiLCBcInZlcmlmeVwiKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVjRFNBLkFMR19OQU1FID0gQWxnb3JpdGhtTmFtZXMuRWNEU0E7XHJcbiAgICBFY0RTQS5LRVlfVVNBR0VTID0gW1wic2lnblwiLCBcInZlcmlmeVwiXTtcclxuICAgIHJldHVybiBFY0RTQTtcclxufShFYykpO1xyXG52YXIgRWNESCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRWNESCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVjREgoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRWNESC5jaGVja0Rlcml2ZVBhcmFtcyA9IGZ1bmN0aW9uIChhbGdvcml0aG0pIHtcclxuICAgICAgICB2YXIgcGFyYW1QdWJsaWMgPSBcInB1YmxpY1wiO1xyXG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICBpZiAoIWFsZ29yaXRobS5wdWJsaWMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVjQWxnb3JpdGhtRXJyb3IoRWNBbGdvcml0aG1FcnJvci5QQVJBTV9SRVFVSVJFRCwgcGFyYW1QdWJsaWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoZWNrS2V5KGFsZ29yaXRobS5wdWJsaWMsIHRoaXMuQUxHX05BTUUsIFwicHVibGljXCIpO1xyXG4gICAgfTtcclxuICAgIEVjREguZGVyaXZlQml0cyA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tEZXJpdmVQYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoYmFzZUtleSwgX3RoaXMuQUxHX05BTUUsIFwicHJpdmF0ZVwiLCBcImRlcml2ZUJpdHNcIik7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFY0RILmRlcml2ZUtleSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGJhc2VLZXksIGRlcml2ZWRLZXlUeXBlLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0Rlcml2ZVBhcmFtcyhhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleShiYXNlS2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwcml2YXRlXCIsIFwiZGVyaXZlS2V5XCIpO1xyXG4gICAgICAgICAgICBCYXNlQ3J5cHRvLmNoZWNrQWxnb3JpdGhtKGRlcml2ZWRLZXlUeXBlKTtcclxuICAgICAgICAgICAgc3dpdGNoIChkZXJpdmVkS2V5VHlwZS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzQ0JDOlxyXG4gICAgICAgICAgICAgICAgICAgIEFlc0NCQy5jaGVja0tleUdlblBhcmFtcyhkZXJpdmVkS2V5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0NUUjpcclxuICAgICAgICAgICAgICAgICAgICBBZXNDVFIuY2hlY2tLZXlHZW5QYXJhbXMoZGVyaXZlZEtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNHQ006XHJcbiAgICAgICAgICAgICAgICAgICAgQWVzR0NNLmNoZWNrS2V5R2VuUGFyYW1zKGRlcml2ZWRLZXlUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzS1c6XHJcbiAgICAgICAgICAgICAgICAgICAgQWVzS1cuY2hlY2tLZXlHZW5QYXJhbXMoZGVyaXZlZEtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRWNBbGdvcml0aG1FcnJvcihcIlVuc3VwcG9ydGVkIG5hbWUgJ1wiICsgZGVyaXZlZEtleVR5cGUubmFtZSArIFwiJyBmb3IgYWxnb3JpdGhtIGluIHBhcmFtICdkZXJpdmVkS2V5VHlwZSdcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVjREguQUxHX05BTUUgPSBBbGdvcml0aG1OYW1lcy5FY0RIO1xyXG4gICAgRWNESC5LRVlfVVNBR0VTID0gW1wiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcclxuICAgIHJldHVybiBFY0RIO1xyXG59KEVjKSk7XG5cbnZhciBIbWFjID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIbWFjLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSG1hYygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBIbWFjLmNoZWNrQWxnb3JpdGhtID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIGlmIChhbGcubmFtZS50b1VwcGVyQ2FzZSgpICE9PSB0aGlzLkFMR19OQU1FLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLldST05HX0FMR19OQU1FLCBhbGcubmFtZSwgdGhpcy5BTEdfTkFNRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhtYWMuY2hlY2tLZXlHZW5QYXJhbXMgPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgaWYgKFwibGVuZ3RoXCIgaW4gYWxnICYmICEoYWxnLmxlbmd0aCA+IDAgJiYgYWxnLmxlbmd0aCA8PSA1MTIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihBbGdvcml0aG1FcnJvci5QQVJBTV9XUk9OR19WQUxVRSwgXCJsZW5ndGhcIiwgXCJtb3JlIDAgYW5kIGxlc3MgdGhhbiA1MTJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhtYWMuY2hlY2tLZXlHZW5Vc2FnZXMgPSBmdW5jdGlvbiAoa2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNoZWNrS2V5VXNhZ2VzKGtleVVzYWdlcyk7XHJcbiAgICAgICAga2V5VXNhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHVzYWdlKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgX3RoaXMuS0VZX1VTQUdFUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLktFWV9VU0FHRVNbaV0udG9Mb3dlckNhc2UoKSA9PT0gdXNhZ2UudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpID09PSBfdGhpcy5LRVlfVVNBR0VTLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNyeXB0b0Vycm9yKFwiVW5zdXBwb3J0ZWQga2V5IHVzYWdlICdcIiArIHVzYWdlICsgXCInLiBTaG91bGQgYmUgb25lIG9mIFtcIiArIF90aGlzLktFWV9VU0FHRVMuam9pbihcIiwgXCIpICsgXCJdXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSG1hYy5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5R2VuUGFyYW1zKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5R2VuVXNhZ2VzKGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIbWFjLmV4cG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrRm9ybWF0KGZvcm1hdCwga2V5LnR5cGUpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSG1hYy5pbXBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrRm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgICAgIGlmICghKGZvcm1hdC50b0xvd2VyQ2FzZSgpID09PSBcInJhd1wiIHx8IGZvcm1hdC50b0xvd2VyQ2FzZSgpID09PSBcImp3a1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLkFMTE9XRURfRk9STUFULCBmb3JtYXQsIFwiJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXlHZW5Vc2FnZXMoa2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhtYWMuc2lnbiA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJzZWNyZXRcIiwgXCJzaWduXCIpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSG1hYy52ZXJpZnkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJzZWNyZXRcIiwgXCJ2ZXJpZnlcIik7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIbWFjLkFMR19OQU1FID0gQWxnb3JpdGhtTmFtZXMuSG1hYztcclxuICAgIEhtYWMuS0VZX1VTQUdFUyA9IFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl07XHJcbiAgICByZXR1cm4gSG1hYztcclxufShCYXNlQ3J5cHRvKSk7XG5cbnZhciBQYmtkZjIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBia2RmMiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBia2RmMigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQYmtkZjIuY2hlY2tBbGdvcml0aG0gPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgaWYgKGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkgIT09IHRoaXMuQUxHX05BTUUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuV1JPTkdfQUxHX05BTUUsIGFsZy5uYW1lLCB0aGlzLkFMR19OQU1FKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGJrZGYyLmNoZWNrRGVyaXZlUGFyYW1zID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG0oYWxnKTtcclxuICAgICAgICBpZiAoYWxnLnNhbHQpIHtcclxuICAgICAgICAgICAgaWYgKCEoQXJyYXlCdWZmZXIuaXNWaWV3KGFsZy5zYWx0KSB8fCBhbGcuc2FsdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlBBUkFNX1dST05HX1RZUEUsIFwic2FsdFwiLCBcIkFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlld1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlBBUkFNX1JFUVVJUkVELCBcInNhbHRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxnLml0ZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlBBUkFNX1JFUVVJUkVELCBcIml0ZXJhdGlvbnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxnLmhhc2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlBBUkFNX1JFUVVJUkVELCBcImhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYXNoID0gUHJlcGFyZUFsZ29yaXRobShhbGcuaGFzaCk7XHJcbiAgICAgICAgU2hhLmNoZWNrQWxnb3JpdGhtKGhhc2gpO1xyXG4gICAgfTtcclxuICAgIFBia2RmMi5pbXBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChleHRyYWN0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNyeXB0b0Vycm9yKFwiS0RGIGtleXMgbXVzdCBzZXQgZXh0cmFjdGFibGU9ZmFsc2VcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tGb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdC50b0xvd2VyQ2FzZSgpICE9PSBcInJhd1wiKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvS2V5RXJyb3IoQ3J5cHRvS2V5RXJyb3IuQUxMT1dFRF9GT1JNQVQsIGZvcm1hdCwgXCIncmF3J1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleVVzYWdlcyhrZXlVc2FnZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFBia2RmMi5kZXJpdmVLZXkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tEZXJpdmVQYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoYmFzZUtleSwgX3RoaXMuQUxHX05BTUUsIFwic2VjcmV0XCIsIFwiZGVyaXZlS2V5XCIpO1xyXG4gICAgICAgICAgICBCYXNlQ3J5cHRvLmNoZWNrQWxnb3JpdGhtKGRlcml2ZWRLZXlUeXBlKTtcclxuICAgICAgICAgICAgc3dpdGNoIChkZXJpdmVkS2V5VHlwZS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzQ0JDOlxyXG4gICAgICAgICAgICAgICAgICAgIEFlc0NCQy5jaGVja0tleUdlblBhcmFtcyhkZXJpdmVkS2V5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgQWVzQ0JDLmNoZWNrS2V5VXNhZ2VzKGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0NUUjpcclxuICAgICAgICAgICAgICAgICAgICBBZXNDVFIuY2hlY2tLZXlHZW5QYXJhbXMoZGVyaXZlZEtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIEFlc0NUUi5jaGVja0tleVVzYWdlcyhrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNHQ006XHJcbiAgICAgICAgICAgICAgICAgICAgQWVzR0NNLmNoZWNrS2V5R2VuUGFyYW1zKGRlcml2ZWRLZXlUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBBZXNHQ00uY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzS1c6XHJcbiAgICAgICAgICAgICAgICAgICAgQWVzS1cuY2hlY2tLZXlHZW5QYXJhbXMoZGVyaXZlZEtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIEFlc0tXLmNoZWNrS2V5VXNhZ2VzKGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkhtYWM6XHJcbiAgICAgICAgICAgICAgICAgICAgSG1hYy5jaGVja0tleUdlblBhcmFtcyhkZXJpdmVkS2V5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgSG1hYy5jaGVja0tleVVzYWdlcyhrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBkZXJpdmVkS2V5VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQYmtkZjIuZGVyaXZlQml0cyA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tEZXJpdmVQYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoYmFzZUtleSwgX3RoaXMuQUxHX05BTUUsIFwic2VjcmV0XCIsIFwiZGVyaXZlQml0c1wiKTtcclxuICAgICAgICAgICAgaWYgKCEobGVuZ3RoICYmIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoXCJQYXJhbWV0ZXIgJ2xlbmd0aCcgbXVzdCBiZSBOdW1iZXIgYW5kIG1vcmUgdGhhbiAwXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUGJrZGYyLkFMR19OQU1FID0gQWxnb3JpdGhtTmFtZXMuUGJrZGYyO1xyXG4gICAgUGJrZGYyLktFWV9VU0FHRVMgPSBbXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xyXG4gICAgcmV0dXJuIFBia2RmMjtcclxufShCYXNlQ3J5cHRvKSk7XG5cbnZhciBQb2x5MTMwNSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUG9seTEzMDUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQb2x5MTMwNSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQb2x5MTMwNS5jaGVja0tleUdlblVzYWdlcyA9IGZ1bmN0aW9uIChrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzKTtcclxuICAgICAgICBrZXlVc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAodXNhZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBfdGhpcy5LRVlfVVNBR0VTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuS0VZX1VTQUdFU1tpXS50b0xvd2VyQ2FzZSgpID09PSB1c2FnZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IF90aGlzLktFWV9VU0FHRVMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ3J5cHRvRXJyb3IoXCJVbnN1cHBvcnRlZCBrZXkgdXNhZ2UgJ1wiICsgdXNhZ2UgKyBcIicuIFNob3VsZCBiZSBvbmUgb2YgW1wiICsgX3RoaXMuS0VZX1VTQUdFUy5qb2luKFwiLCBcIikgKyBcIl1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQb2x5MTMwNS5leHBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5KGtleSwgX3RoaXMuQUxHX05BTUUpO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0Zvcm1hdChmb3JtYXQsIGtleS50eXBlKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFBvbHkxMzA1LmltcG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tGb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICAgICAgaWYgKCEoZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwicmF3XCIgfHwgZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwiandrXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvS2V5RXJyb3IoQ3J5cHRvS2V5RXJyb3IuQUxMT1dFRF9GT1JNQVQsIGZvcm1hdCwgXCInandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleUdlblVzYWdlcyhrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9seTEzMDUuc2lnbiA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJzZWNyZXRcIiwgXCJzaWduXCIpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9seTEzMDUudmVyaWZ5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5KGtleSwgX3RoaXMuQUxHX05BTUUsIFwic2VjcmV0XCIsIFwidmVyaWZ5XCIpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9seTEzMDUuY2hlY2tLZXkgPSBmdW5jdGlvbiAoa2V5LCBhbGcsIHR5cGUsIHVzYWdlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICh1c2FnZSA9PT0gdm9pZCAwKSB7IHVzYWdlID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5FTVBUWV9LRVkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSAmJiAoIWtleS50eXBlIHx8IGtleS50eXBlLnRvVXBwZXJDYXNlKCkgIT09IHR5cGUudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0tleUVycm9yKENyeXB0b0tleUVycm9yLldST05HX0tFWV9UWVBFLCBrZXkudHlwZSwgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2FnZSkge1xyXG4gICAgICAgICAgICBpZiAoIWtleS51c2FnZXMuc29tZShmdW5jdGlvbiAoa2V5VXNhZ2UpIHsgcmV0dXJuIHVzYWdlLnRvVXBwZXJDYXNlKCkgPT09IGtleVVzYWdlLnRvVXBwZXJDYXNlKCk7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvS2V5RXJyb3IoQ3J5cHRvS2V5RXJyb3IuV1JPTkdfS0VZX1VTQUdFLCB1c2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUG9seTEzMDUuQUxHX05BTUUgPSBBbGdvcml0aG1OYW1lcy5Qb2x5MTMwNTtcclxuICAgIFBvbHkxMzA1LktFWV9VU0FHRVMgPSBbXCJzaWduXCIsIFwidmVyaWZ5XCJdO1xyXG4gICAgcmV0dXJuIFBvbHkxMzA1O1xyXG59KEJhc2VDcnlwdG8pKTtcblxudmFyIFJzYUtleUdlblBhcmFtc0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSc2FLZXlHZW5QYXJhbXNFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJzYUtleUdlblBhcmFtc0Vycm9yKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNvZGUgPSAyO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBSc2FLZXlHZW5QYXJhbXNFcnJvcjtcclxufShBbGdvcml0aG1FcnJvcikpO1xyXG52YXIgUnNhSGFzaGVkSW1wb3J0UGFyYW1zRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJzYUhhc2hlZEltcG9ydFBhcmFtc0Vycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUnNhSGFzaGVkSW1wb3J0UGFyYW1zRXJyb3IoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29kZSA9IDY7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJzYUhhc2hlZEltcG9ydFBhcmFtc0Vycm9yO1xyXG59KEFsZ29yaXRobUVycm9yKSk7XHJcbnZhciBSc2EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJzYSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJzYSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBSc2EuY2hlY2tBbGdvcml0aG0gPSBmdW5jdGlvbiAoYWxnKSB7XHJcbiAgICAgICAgaWYgKGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkgIT09IHRoaXMuQUxHX05BTUUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuV1JPTkdfQUxHX05BTUUsIGFsZy5uYW1lLCB0aGlzLkFMR19OQU1FKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUnNhLmNoZWNrSW1wb3J0QWxnb3JpdGhtID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG0oYWxnKTtcclxuICAgICAgICBpZiAoIWFsZy5oYXNoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSc2FIYXNoZWRJbXBvcnRQYXJhbXNFcnJvcihSc2FIYXNoZWRJbXBvcnRQYXJhbXNFcnJvci5QQVJBTV9SRVFVSVJFRCwgXCJoYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTaGEuY2hlY2tBbGdvcml0aG0oYWxnLmhhc2gpO1xyXG4gICAgfTtcclxuICAgIFJzYS5jaGVja0tleUdlblBhcmFtcyA9IGZ1bmN0aW9uIChhbGcpIHtcclxuICAgICAgICB2YXIgbW9kdWx1c0JpdHMgPSBhbGcubW9kdWx1c0xlbmd0aDtcclxuICAgICAgICBpZiAoIShtb2R1bHVzQml0cyA+PSAyNTYgJiYgbW9kdWx1c0JpdHMgPD0gMTYzODQgJiYgIShtb2R1bHVzQml0cyAlIDgpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUnNhS2V5R2VuUGFyYW1zRXJyb3IoUnNhS2V5R2VuUGFyYW1zRXJyb3IuUEFSQU1fV1JPTkdfVkFMVUUsIFwibW9kdWx1c0xlbmd0aFwiLCBcIiBhIG11bHRpcGxlIG9mIDggYml0cyBhbmQgPj0gMjU2IGFuZCA8PSAxNjM4NFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHB1YkV4cCA9IGFsZy5wdWJsaWNFeHBvbmVudDtcclxuICAgICAgICBpZiAoIXB1YkV4cCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUnNhS2V5R2VuUGFyYW1zRXJyb3IoUnNhS2V5R2VuUGFyYW1zRXJyb3IuUEFSQU1fUkVRVUlSRUQsIFwicHVibGljRXhwb25lbnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHB1YkV4cCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJzYUtleUdlblBhcmFtc0Vycm9yKFJzYUtleUdlblBhcmFtc0Vycm9yLlBBUkFNX1dST05HX1RZUEUsIFwicHVibGljRXhwb25lbnRcIiwgXCJBcnJheUJ1ZmZlclZpZXdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHB1YkV4cFswXSA9PT0gMyB8fCAocHViRXhwWzBdID09PSAxICYmIHB1YkV4cFsxXSA9PT0gMCAmJiBwdWJFeHBbMl0gPT09IDEpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUnNhS2V5R2VuUGFyYW1zRXJyb3IoUnNhS2V5R2VuUGFyYW1zRXJyb3IuUEFSQU1fV1JPTkdfVkFMVUUsIFwicHVibGljRXhwb25lbnRcIiwgXCJVaW50OEFycmF5KFszXSkgfCBVaW50OEFycmF5KFsxLCAwLCAxXSlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxnLmhhc2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJzYUtleUdlblBhcmFtc0Vycm9yKFJzYUtleUdlblBhcmFtc0Vycm9yLlBBUkFNX1JFUVVJUkVELCBcImhhc2hcIiwgU2hhQWxnb3JpdGhtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNoYS5jaGVja0FsZ29yaXRobShhbGcuaGFzaCk7XHJcbiAgICB9O1xyXG4gICAgUnNhLmNoZWNrS2V5R2VuVXNhZ2VzID0gZnVuY3Rpb24gKGtleVVzYWdlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jaGVja0tleVVzYWdlcyhrZXlVc2FnZXMpO1xyXG4gICAgICAgIGtleVVzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uICh1c2FnZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IF90aGlzLktFWV9VU0FHRVMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5LRVlfVVNBR0VTW2ldLnRvTG93ZXJDYXNlKCkgPT09IHVzYWdlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gX3RoaXMuS0VZX1VTQUdFUy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXZWJDcnlwdG9FcnJvcihcIlVuc3VwcG9ydGVkIGtleSB1c2FnZSAnXCIgKyB1c2FnZSArIFwiJy4gU2hvdWxkIGJlIG9uZSBvZiBbXCIgKyBfdGhpcy5LRVlfVVNBR0VTLmpvaW4oXCIsIFwiKSArIFwiXVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJzYS5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5R2VuUGFyYW1zKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5R2VuVXNhZ2VzKGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSc2EuZXhwb3J0S2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleShrZXksIF90aGlzLkFMR19OQU1FKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tGb3JtYXQoZm9ybWF0LCBrZXkudHlwZSk7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSc2EuaW1wb3J0S2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0ltcG9ydEFsZ29yaXRobShhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0Zvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwicmF3XCIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5BTExPV0VEX0ZPUk1BVCwgZm9ybWF0LCBcIidKc29uV2ViS2V5JywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXlHZW5Vc2FnZXMoa2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJzYS5BTEdfTkFNRSA9IFwiXCI7XHJcbiAgICBSc2EuS0VZX1VTQUdFUyA9IFtdO1xyXG4gICAgcmV0dXJuIFJzYTtcclxufShCYXNlQ3J5cHRvKSk7XHJcbnZhciBSc2FTU0EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJzYVNTQSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJzYVNTQSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBSc2FTU0Euc2lnbiA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwcml2YXRlXCIsIFwic2lnblwiKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJzYVNTQS52ZXJpZnkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwdWJsaWNcIiwgXCJ2ZXJpZnlcIik7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSc2FTU0EuQUxHX05BTUUgPSBBbGdvcml0aG1OYW1lcy5Sc2FTU0E7XHJcbiAgICBSc2FTU0EuS0VZX1VTQUdFUyA9IFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl07XHJcbiAgICByZXR1cm4gUnNhU1NBO1xyXG59KFJzYSkpO1xyXG52YXIgUnNhUFNTUGFyYW1zRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJzYVBTU1BhcmFtc0Vycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUnNhUFNTUGFyYW1zRXJyb3IoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29kZSA9IDQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJzYVBTU1BhcmFtc0Vycm9yO1xyXG59KEFsZ29yaXRobUVycm9yKSk7XHJcbnZhciBSc2FQU1MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJzYVBTUywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJzYVBTUygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBSc2FQU1MuY2hlY2tBbGdvcml0aG1QYXJhbXMgPSBmdW5jdGlvbiAoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgdmFyIGFsZyA9IGFsZ29yaXRobTtcclxuICAgICAgICBfc3VwZXIuY2hlY2tBbGdvcml0aG1QYXJhbXMuY2FsbCh0aGlzLCBhbGcpO1xyXG4gICAgICAgIGlmICghYWxnLnNhbHRMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJzYVBTU1BhcmFtc0Vycm9yKFJzYVBTU1BhcmFtc0Vycm9yLlBBUkFNX1JFUVVJUkVELCBcInNhbHRMZW5ndGhcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbGcuc2FsdExlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJzYVBTU1BhcmFtc0Vycm9yKFwiUGFyYW1ldGVyICdzYWx0TGVuZ3RoJyBpcyBvdXRzaWRlIG9mIG51bWVyaWMgcmFuZ2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJzYVBTUy5BTEdfTkFNRSA9IEFsZ29yaXRobU5hbWVzLlJzYVBTUztcclxuICAgIHJldHVybiBSc2FQU1M7XHJcbn0oUnNhU1NBKSk7XHJcbnZhciBSc2FPQUVQUGFyYW1zRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJzYU9BRVBQYXJhbXNFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJzYU9BRVBQYXJhbXNFcnJvcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jb2RlID0gNTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUnNhT0FFUFBhcmFtc0Vycm9yO1xyXG59KEFsZ29yaXRobUVycm9yKSk7XHJcbnZhciBSc2FPQUVQID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSc2FPQUVQLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUnNhT0FFUCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBSc2FPQUVQLmNoZWNrQWxnb3JpdGhtUGFyYW1zID0gZnVuY3Rpb24gKGFsZykge1xyXG4gICAgICAgIGlmIChhbGcubGFiZWwpIHtcclxuICAgICAgICAgICAgaWYgKCEoQXJyYXlCdWZmZXIuaXNWaWV3KGFsZy5sYWJlbCkgfHwgYWxnLmxhYmVsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUnNhT0FFUFBhcmFtc0Vycm9yKFJzYU9BRVBQYXJhbXNFcnJvci5QQVJBTV9XUk9OR19UWVBFLCBcImxhYmVsXCIsIFwiQXJyYXlCdWZmZXJWaWV3IG9yIEFycmF5QnVmZmVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJzYU9BRVAuZW5jcnlwdCA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tLZXkoa2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwdWJsaWNcIiwgXCJlbmNyeXB0XCIpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUnNhT0FFUC5kZWNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleShrZXksIF90aGlzLkFMR19OQU1FLCBcInByaXZhdGVcIiwgXCJkZWNyeXB0XCIpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUnNhT0FFUC53cmFwS2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5LCB3cmFwcGluZ0tleSwgd3JhcEFsZ29yaXRobSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMod3JhcEFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNoZWNrS2V5KHdyYXBwaW5nS2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwdWJsaWNcIiwgXCJ3cmFwS2V5XCIpO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja1dyYXBwZWRLZXkoa2V5KTtcclxuICAgICAgICAgICAgX3RoaXMuY2hlY2tGb3JtYXQoZm9ybWF0LCBrZXkudHlwZSk7XHJcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSc2FPQUVQLnVud3JhcEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIHdyYXBwZWRLZXksIHVud3JhcHBpbmdLZXksIHVud3JhcEFsZ29yaXRobSwgdW53cmFwcGVkS2V5QWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyh1bndyYXBBbGdvcml0aG0pO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0tleSh1bndyYXBwaW5nS2V5LCBfdGhpcy5BTEdfTkFNRSwgXCJwcml2YXRlXCIsIFwidW53cmFwS2V5XCIpO1xyXG4gICAgICAgICAgICBfdGhpcy5jaGVja0Zvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUnNhT0FFUC5BTEdfTkFNRSA9IEFsZ29yaXRobU5hbWVzLlJzYU9BRVA7XHJcbiAgICBSc2FPQUVQLktFWV9VU0FHRVMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XHJcbiAgICByZXR1cm4gUnNhT0FFUDtcclxufShSc2EpKTtcblxudmFyIFN1YnRsZUNyeXB0byA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdWJ0bGVDcnlwdG8oKSB7XHJcbiAgICB9XHJcbiAgICBTdWJ0bGVDcnlwdG8ucHJvdG90eXBlLmdlbmVyYXRlS2V5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhbGcgPSBQcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IEJhc2VDcnlwdG87XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5Sc2FTU0EudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFJzYVNTQTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhT0FFUC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUnNhT0FFUDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhUFNTLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBSc2FQU1M7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0VDQi50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzRUNCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNDQkMudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0NCQztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzQ1RSLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNDVFI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0dDTS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzR0NNO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNLVy50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzS1c7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkVjRFNBLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBFY0RTQTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuRWREU0EudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEVkRFNBO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5FY0RILnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBFY0RIO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5IbWFjLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBIbWFjO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGcubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ2xhc3MuZ2VuZXJhdGVLZXkoYWxnLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFsZyA9IFByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgdmFyIGJ1ZiA9IFByZXBhcmVEYXRhKGRhdGEsIFwiZGF0YVwiKTtcclxuICAgICAgICAgICAgdmFyIENsYXNzID0gQmFzZUNyeXB0bztcclxuICAgICAgICAgICAgc3dpdGNoIChhbGcubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlNoYTEudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuU2hhMjU2LnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlNoYTM4NC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5TaGE1MTIudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFNoYTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwgYWxnLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENsYXNzLmRpZ2VzdChhbGcsIGJ1ZikudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN1YnRsZUNyeXB0by5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhbGcgPSBQcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIHZhciBidWYgPSBQcmVwYXJlRGF0YShkYXRhLCBcImRhdGFcIik7XHJcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IEJhc2VDcnlwdG87XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5Sc2FTU0EudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFJzYVNTQTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhUFNTLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBSc2FQU1M7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkVjRFNBLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBFY0RTQTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuRWREU0EudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEVkRFNBO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5IbWFjLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBIbWFjO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5Qb2x5MTMwNS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUG9seTEzMDU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihBbGdvcml0aG1FcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZy5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDbGFzcy5zaWduKGFsZywga2V5LCBidWYpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTdWJ0bGVDcnlwdG8ucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFsZyA9IFByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgdmFyIHNpZ0J1ZiA9IFByZXBhcmVEYXRhKGRhdGEsIFwic2lnbmF0dXJlXCIpO1xyXG4gICAgICAgICAgICB2YXIgYnVmID0gUHJlcGFyZURhdGEoZGF0YSwgXCJkYXRhXCIpO1xyXG4gICAgICAgICAgICB2YXIgQ2xhc3MgPSBCYXNlQ3J5cHRvO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhU1NBLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBSc2FTU0E7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlJzYVBTUy50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUnNhUFNTO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5FY0RTQS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gRWNEU0E7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkVkRFNBLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBFZERTQTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuSG1hYy50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gSG1hYztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUG9seTEzMDUudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFBvbHkxMzA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGcubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ2xhc3MudmVyaWZ5KGFsZywga2V5LCBzaWdCdWYsIGJ1ZikudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN1YnRsZUNyeXB0by5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhbGcgPSBQcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIHZhciBidWYgPSBQcmVwYXJlRGF0YShkYXRhLCBcImRhdGFcIik7XHJcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IEJhc2VDcnlwdG87XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5Sc2FPQUVQLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBSc2FPQUVQO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNFQ0IudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0VDQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzQ0JDLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNDQkM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0NUUi50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzQ1RSO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNHQ00udG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0dDTTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQ2hhQ2hhMjAudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IENoYUNoYTIwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGcubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ2xhc3MuZW5jcnlwdChhbGcsIGtleSwgYnVmKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFsZyA9IFByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgdmFyIGJ1ZiA9IFByZXBhcmVEYXRhKGRhdGEsIFwiZGF0YVwiKTtcclxuICAgICAgICAgICAgdmFyIENsYXNzID0gQmFzZUNyeXB0bztcclxuICAgICAgICAgICAgc3dpdGNoIChhbGcubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlJzYU9BRVAudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFJzYU9BRVA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0VDQi50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzRUNCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNDQkMudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0NCQztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzQ1RSLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNDVFI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0dDTS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzR0NNO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5DaGFDaGEyMC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQ2hhQ2hhMjA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihBbGdvcml0aG1FcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZy5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDbGFzcy5kZWNyeXB0KGFsZywga2V5LCBidWYpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTdWJ0bGVDcnlwdG8ucHJvdG90eXBlLmRlcml2ZUJpdHMgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYWxnID0gUHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xyXG4gICAgICAgICAgICB2YXIgQ2xhc3MgPSBCYXNlQ3J5cHRvO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuRWNESC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gRWNESDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUGJrZGYyLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBQYmtkZjI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihBbGdvcml0aG1FcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZy5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDbGFzcy5kZXJpdmVCaXRzKGFsZywgYmFzZUtleSwgbGVuZ3RoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5kZXJpdmVLZXkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhbGcgPSBQcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkQWxnID0gUHJlcGFyZUFsZ29yaXRobShkZXJpdmVkS2V5VHlwZSk7XHJcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IEJhc2VDcnlwdG87XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5FY0RILnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBFY0RIO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5QYmtkZjIudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFBia2RmMjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwgYWxnLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENsYXNzLmRlcml2ZUtleShhbGcsIGJhc2VLZXksIGRlcml2ZWRBbGcsIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTdWJ0bGVDcnlwdG8ucHJvdG90eXBlLmV4cG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIEJhc2VDcnlwdG8uY2hlY2tLZXkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFrZXkuZXh0cmFjdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9LZXlFcnJvcihDcnlwdG9LZXlFcnJvci5OT1RfRVhUUkFDVEFCTEUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IEJhc2VDcnlwdG87XHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhU1NBLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBSc2FTU0E7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlJzYVBTUy50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUnNhUFNTO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNFQ0IudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0VDQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhT0FFUC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUnNhT0FFUDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzQ0JDLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNDQkM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0NUUi50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzQ1RSO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNHQ00udG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0dDTTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzS1cudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0tXO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5FY0RTQS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gRWNEU0E7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkVkRFNBLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBFZERTQTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuRWNESC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gRWNESDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuSG1hYy50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gSG1hYztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUG9seTEzMDUudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFBvbHkxMzA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBrZXkuYWxnb3JpdGhtLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENsYXNzLmV4cG9ydEtleShmb3JtYXQsIGtleSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN1YnRsZUNyeXB0by5wcm90b3R5cGUuaW1wb3J0S2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFsZyA9IFByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgdmFyIENsYXNzID0gQmFzZUNyeXB0bztcclxuICAgICAgICAgICAgc3dpdGNoIChhbGcubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlJzYVNTQS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUnNhU1NBO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5Sc2FQU1MudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IFJzYVBTUztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhT0FFUC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUnNhT0FFUDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzRUNCLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNFQ0I7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0NCQy50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzQ0JDO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNDVFIudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0NUUjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzR0NNLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNHQ007XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0tXLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNLVztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuRWNEU0EudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEVjRFNBO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5FZERTQS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gRWREU0E7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkVjREgudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEVjREg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkhtYWMudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEhtYWM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLlBia2RmMi50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUGJrZGYyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5Qb2x5MTMwNS50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUG9seTEzMDU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihBbGdvcml0aG1FcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZy5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDbGFzcy5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGcsIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTdWJ0bGVDcnlwdG8ucHJvdG90eXBlLndyYXBLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXksIHdyYXBwaW5nS2V5LCB3cmFwQWxnb3JpdGhtKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFsZyA9IFByZXBhcmVBbGdvcml0aG0od3JhcEFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IEJhc2VDcnlwdG87XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5Sc2FPQUVQLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBSc2FPQUVQO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNFQ0IudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0VDQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzQ0JDLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNDQkM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0NUUi50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzQ1RSO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNHQ00udG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0dDTTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzS1cudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0tXO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoQWxnb3JpdGhtRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGcubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ2xhc3Mud3JhcEtleShmb3JtYXQsIGtleSwgd3JhcHBpbmdLZXksIGFsZykudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN1YnRsZUNyeXB0by5wcm90b3R5cGUudW53cmFwS2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwgd3JhcHBlZEtleSwgdW53cmFwcGluZ0tleSwgdW53cmFwQWxnb3JpdGhtLCB1bndyYXBwZWRLZXlBbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgdW53cmFwQWxnID0gUHJlcGFyZUFsZ29yaXRobSh1bndyYXBBbGdvcml0aG0pO1xyXG4gICAgICAgICAgICB2YXIgdW53cmFwcGVkQWxnID0gUHJlcGFyZUFsZ29yaXRobSh1bndyYXBwZWRLZXlBbGdvcml0aG0pO1xyXG4gICAgICAgICAgICB2YXIgYnVmID0gUHJlcGFyZURhdGEod3JhcHBlZEtleSwgXCJ3cmFwcGVkS2V5XCIpO1xyXG4gICAgICAgICAgICB2YXIgQ2xhc3MgPSBCYXNlQ3J5cHRvO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHVud3JhcEFsZy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuUnNhT0FFUC50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gUnNhT0FFUDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzRUNCLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNFQ0I7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0NCQy50b1VwcGVyQ2FzZSgpOlxyXG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQWVzQ0JDO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBbGdvcml0aG1OYW1lcy5BZXNDVFIudG9VcHBlckNhc2UoKTpcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IEFlc0NUUjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQWxnb3JpdGhtTmFtZXMuQWVzR0NNLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNHQ007XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFsZ29yaXRobU5hbWVzLkFlc0tXLnRvVXBwZXJDYXNlKCk6XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBBZXNLVztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKEFsZ29yaXRobUVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwgdW53cmFwQWxnLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENsYXNzLnVud3JhcEtleShmb3JtYXQsIGJ1ZiwgdW53cmFwcGluZ0tleSwgdW53cmFwQWxnLCB1bndyYXBwZWRBbGcsIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3VidGxlQ3J5cHRvO1xyXG59KCkpO1xuXG5leHBvcnQgeyBXZWJDcnlwdG9FcnJvciwgQWxnb3JpdGhtRXJyb3IsIENyeXB0b0tleUVycm9yLCBQcmVwYXJlQWxnb3JpdGhtLCBQcmVwYXJlRGF0YSwgQmFzZUNyeXB0bywgQWxnb3JpdGhtTmFtZXMsIEJhc2U2NFVybCwgU3VidGxlQ3J5cHRvLCBBZXMsIEFlc0FsZ29yaXRobUVycm9yLCBBZXNXcmFwS2V5LCBBZXNFbmNyeXB0LCBBZXNFQ0IsIEFlc0NCQywgQWVzQ1RSLCBBZXNHQ00sIEFlc0tXLCBSc2FLZXlHZW5QYXJhbXNFcnJvciwgUnNhSGFzaGVkSW1wb3J0UGFyYW1zRXJyb3IsIFJzYSwgUnNhU1NBLCBSc2FQU1NQYXJhbXNFcnJvciwgUnNhUFNTLCBSc2FPQUVQUGFyYW1zRXJyb3IsIFJzYU9BRVAsIEVjS2V5R2VuUGFyYW1zRXJyb3IsIEVjLCBFY0FsZ29yaXRobUVycm9yLCBFZERTQSwgRWNEU0EsIEVjREgsIFNoYUFsZ29yaXRobXMsIFNoYSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webcrypto-core/dist/webcrypto-core.es.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmVyLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcz9jZDAwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2ggKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/aes/crypto.ts":
/*!***************************!*\
  !*** ./src/aes/crypto.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar webcrypto_core_1 = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\nvar error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nvar key_1 = __webpack_require__(/*! ../key */ \"./src/key.ts\");\nvar helper_1 = __webpack_require__(/*! ../helper */ \"./src/helper.ts\");\nvar init_1 = __webpack_require__(/*! ../init */ \"./src/init.ts\");\nvar crypto_1 = __webpack_require__(/*! ../crypto */ \"./src/crypto.ts\");\nvar AesCrypto = /** @class */ (function (_super) {\n    __extends(AesCrypto, _super);\n    function AesCrypto() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AesCrypto.generateKey = function (algorithm, extractable, keyUsages) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            _this.checkModule();\n            // gat random bytes for key\n            var key = init_1.nativeCrypto.getRandomValues(new Uint8Array(algorithm.length / 8));\n            // set key params\n            var aesKey = new key_1.CryptoKey({\n                type: \"secret\",\n                algorithm: algorithm,\n                extractable: extractable,\n                usages: keyUsages,\n            });\n            aesKey.key = key;\n            return aesKey;\n        });\n    };\n    AesCrypto.encrypt = function (algorithm, key, data) {\n        return Promise.resolve()\n            .then(function () {\n            var res;\n            switch (algorithm.name.toUpperCase()) {\n                case webcrypto_core_1.AlgorithmNames.AesECB:\n                    var algECB = algorithm;\n                    res = asmCrypto.AES_ECB.encrypt(data, key.key, !!algECB.padding);\n                    break;\n                case webcrypto_core_1.AlgorithmNames.AesCBC:\n                    var algCBC = algorithm;\n                    res = asmCrypto.AES_CBC.encrypt(data, key.key, undefined, webcrypto_core_1.PrepareData(algCBC.iv, \"iv\"));\n                    break;\n                case webcrypto_core_1.AlgorithmNames.AesGCM:\n                    var algGCM = algorithm;\n                    algGCM.tagLength = algGCM.tagLength || 128;\n                    var additionalData = void 0;\n                    if (algGCM.additionalData) {\n                        additionalData = webcrypto_core_1.PrepareData(algGCM.additionalData, \"additionalData\");\n                    }\n                    res = asmCrypto.AES_GCM.encrypt(data, key.key, algGCM.iv, additionalData, algGCM.tagLength / 8);\n                    break;\n                default:\n                    throw new error_1.LinerError(webcrypto_core_1.AlgorithmError.UNSUPPORTED_ALGORITHM, algorithm.name);\n            }\n            return res.buffer;\n        });\n    };\n    AesCrypto.decrypt = function (algorithm, key, data) {\n        return Promise.resolve()\n            .then(function () {\n            var res;\n            switch (algorithm.name.toUpperCase()) {\n                case webcrypto_core_1.AlgorithmNames.AesECB:\n                    var algECB = algorithm;\n                    res = asmCrypto.AES_ECB.decrypt(data, key.key, !!algECB.padding);\n                    break;\n                case webcrypto_core_1.AlgorithmNames.AesCBC:\n                    var algCBC = algorithm;\n                    res = asmCrypto.AES_CBC.decrypt(data, key.key, undefined, webcrypto_core_1.PrepareData(algCBC.iv, \"iv\"));\n                    break;\n                case webcrypto_core_1.AlgorithmNames.AesGCM:\n                    var algGCM = algorithm;\n                    algGCM.tagLength = algGCM.tagLength || 128;\n                    var additionalData = void 0;\n                    if (algGCM.additionalData) {\n                        additionalData = webcrypto_core_1.PrepareData(algGCM.additionalData, \"additionalData\");\n                    }\n                    res = asmCrypto.AES_GCM.decrypt(data, key.key, algGCM.iv, additionalData, algGCM.tagLength / 8);\n                    break;\n                default:\n                    throw new error_1.LinerError(webcrypto_core_1.AlgorithmError.UNSUPPORTED_ALGORITHM, algorithm.name);\n            }\n            return res.buffer;\n        });\n    };\n    AesCrypto.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {\n        var crypto;\n        return Promise.resolve()\n            .then(function () {\n            crypto = new crypto_1.Crypto();\n            return crypto.subtle.exportKey(format, key);\n        })\n            .then(function (data) {\n            var raw;\n            if (!(data instanceof ArrayBuffer)) {\n                // JWK\n                raw = helper_1.string2buffer(JSON.stringify(data));\n            }\n            else {\n                // ArrayBuffer\n                raw = new Uint8Array(data);\n            }\n            var copyKey = wrappingKey.copy([\"encrypt\"]);\n            return crypto.subtle.encrypt(wrapAlgorithm, copyKey, raw);\n        });\n    };\n    AesCrypto.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\n        var crypto;\n        return Promise.resolve()\n            .then(function () {\n            crypto = new crypto_1.Crypto();\n            var copyKey = unwrappingKey.copy([\"decrypt\"]);\n            return crypto.subtle.decrypt(unwrapAlgorithm, copyKey, wrappedKey);\n        })\n            .then(function (data) {\n            var dataAny;\n            if (format.toLowerCase() === \"jwk\") {\n                dataAny = JSON.parse(helper_1.buffer2string(new Uint8Array(data)));\n            }\n            else {\n                dataAny = new Uint8Array(data);\n            }\n            return crypto.subtle.importKey(format, dataAny, unwrappedKeyAlgorithm, extractable, keyUsages);\n        });\n    };\n    AesCrypto.alg2jwk = function (alg) {\n        return \"A\" + alg.length + /-(\\w+)/i.exec(alg.name.toUpperCase())[1];\n    };\n    AesCrypto.jwk2alg = function (alg) {\n        throw new Error(\"Not implemented\");\n    };\n    AesCrypto.exportKey = function (format, key) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            var raw = key.key;\n            if (format.toLowerCase() === \"jwk\") {\n                var jwk = {\n                    alg: _this.alg2jwk(key.algorithm),\n                    ext: key.extractable,\n                    k: webcrypto_core_1.Base64Url.encode(raw),\n                    key_ops: key.usages,\n                    kty: \"oct\",\n                };\n                return jwk;\n            }\n            else {\n                return raw.buffer;\n            }\n        });\n    };\n    AesCrypto.importKey = function (format, keyData, algorithm, extractable, usages) {\n        return __awaiter(this, void 0, void 0, function () {\n            var raw, jwk, key;\n            return __generator(this, function (_a) {\n                if (format.toLowerCase() === \"jwk\") {\n                    jwk = keyData;\n                    raw = webcrypto_core_1.Base64Url.decode(jwk.k);\n                }\n                else {\n                    raw = new Uint8Array(keyData);\n                }\n                key = new key_1.CryptoKey({\n                    type: \"secret\",\n                    algorithm: algorithm,\n                    extractable: extractable,\n                    usages: usages,\n                });\n                key.key = raw;\n                return [2 /*return*/, key];\n            });\n        });\n    };\n    AesCrypto.checkModule = function () {\n        if (typeof asmCrypto === \"undefined\") {\n            throw new error_1.LinerError(error_1.LinerError.MODULE_NOT_FOUND, \"asmCrypto\", \"https://github.com/vibornoff/asmcrypto.js\");\n        }\n    };\n    return AesCrypto;\n}(webcrypto_core_1.BaseCrypto));\nexports.AesCrypto = AesCrypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYWVzL2NyeXB0by50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmVyLy4vc3JjL2Flcy9jcnlwdG8udHM/M2YyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2ViY3J5cHRvX2NvcmVfMSA9IHJlcXVpcmUoXCJ3ZWJjcnlwdG8tY29yZVwiKTtcbnZhciBlcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xudmFyIGtleV8xID0gcmVxdWlyZShcIi4uL2tleVwiKTtcbnZhciBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJcIik7XG52YXIgaW5pdF8xID0gcmVxdWlyZShcIi4uL2luaXRcIik7XG52YXIgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvXCIpO1xudmFyIEFlc0NyeXB0byA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWVzQ3J5cHRvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFlc0NyeXB0bygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2hlY2tNb2R1bGUoKTtcbiAgICAgICAgICAgIC8vIGdhdCByYW5kb20gYnl0ZXMgZm9yIGtleVxuICAgICAgICAgICAgdmFyIGtleSA9IGluaXRfMS5uYXRpdmVDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5sZW5ndGggLyA4KSk7XG4gICAgICAgICAgICAvLyBzZXQga2V5IHBhcmFtc1xuICAgICAgICAgICAgdmFyIGFlc0tleSA9IG5ldyBrZXlfMS5DcnlwdG9LZXkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VjcmV0XCIsXG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgZXh0cmFjdGFibGU6IGV4dHJhY3RhYmxlLFxuICAgICAgICAgICAgICAgIHVzYWdlczoga2V5VXNhZ2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZXNLZXkua2V5ID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIGFlc0tleTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZXNDcnlwdG8uZW5jcnlwdCA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzRUNCOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxnRUNCID0gYWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBhc21DcnlwdG8uQUVTX0VDQi5lbmNyeXB0KGRhdGEsIGtleS5rZXksICEhYWxnRUNCLnBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzQ0JDOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxnQ0JDID0gYWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBhc21DcnlwdG8uQUVTX0NCQy5lbmNyeXB0KGRhdGEsIGtleS5rZXksIHVuZGVmaW5lZCwgd2ViY3J5cHRvX2NvcmVfMS5QcmVwYXJlRGF0YShhbGdDQkMuaXYsIFwiaXZcIikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzR0NNOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxnR0NNID0gYWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgICAgICBhbGdHQ00udGFnTGVuZ3RoID0gYWxnR0NNLnRhZ0xlbmd0aCB8fCAxMjg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsRGF0YSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsZ0dDTS5hZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbERhdGEgPSB3ZWJjcnlwdG9fY29yZV8xLlByZXBhcmVEYXRhKGFsZ0dDTS5hZGRpdGlvbmFsRGF0YSwgXCJhZGRpdGlvbmFsRGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXMgPSBhc21DcnlwdG8uQUVTX0dDTS5lbmNyeXB0KGRhdGEsIGtleS5rZXksIGFsZ0dDTS5pdiwgYWRkaXRpb25hbERhdGEsIGFsZ0dDTS50YWdMZW5ndGggLyA4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcih3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobUVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwgYWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5idWZmZXI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWVzQ3J5cHRvLmRlY3J5cHQgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0VDQjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsZ0VDQiA9IGFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXNtQ3J5cHRvLkFFU19FQ0IuZGVjcnlwdChkYXRhLCBrZXkua2V5LCAhIWFsZ0VDQi5wYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0NCQzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsZ0NCQyA9IGFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXNtQ3J5cHRvLkFFU19DQkMuZGVjcnlwdChkYXRhLCBrZXkua2V5LCB1bmRlZmluZWQsIHdlYmNyeXB0b19jb3JlXzEuUHJlcGFyZURhdGEoYWxnQ0JDLml2LCBcIml2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0dDTTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsZ0dDTSA9IGFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgYWxnR0NNLnRhZ0xlbmd0aCA9IGFsZ0dDTS50YWdMZW5ndGggfHwgMTI4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbERhdGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGdHQ00uYWRkaXRpb25hbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxEYXRhID0gd2ViY3J5cHRvX2NvcmVfMS5QcmVwYXJlRGF0YShhbGdHQ00uYWRkaXRpb25hbERhdGEsIFwiYWRkaXRpb25hbERhdGFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXNtQ3J5cHRvLkFFU19HQ00uZGVjcnlwdChkYXRhLCBrZXkua2V5LCBhbGdHQ00uaXYsIGFkZGl0aW9uYWxEYXRhLCBhbGdHQ00udGFnTGVuZ3RoIC8gOCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3Iod2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1FcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMuYnVmZmVyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFlc0NyeXB0by53cmFwS2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5LCB3cmFwcGluZ0tleSwgd3JhcEFsZ29yaXRobSkge1xuICAgICAgICB2YXIgY3J5cHRvO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyeXB0byA9IG5ldyBjcnlwdG9fMS5DcnlwdG8oKTtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmV4cG9ydEtleShmb3JtYXQsIGtleSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHJhdztcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBKV0tcbiAgICAgICAgICAgICAgICByYXcgPSBoZWxwZXJfMS5zdHJpbmcyYnVmZmVyKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFycmF5QnVmZmVyXG4gICAgICAgICAgICAgICAgcmF3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29weUtleSA9IHdyYXBwaW5nS2V5LmNvcHkoW1wiZW5jcnlwdFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5lbmNyeXB0KHdyYXBBbGdvcml0aG0sIGNvcHlLZXksIHJhdyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWVzQ3J5cHRvLnVud3JhcEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIHdyYXBwZWRLZXksIHVud3JhcHBpbmdLZXksIHVud3JhcEFsZ29yaXRobSwgdW53cmFwcGVkS2V5QWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIHZhciBjcnlwdG87XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3J5cHRvID0gbmV3IGNyeXB0b18xLkNyeXB0bygpO1xuICAgICAgICAgICAgdmFyIGNvcHlLZXkgPSB1bndyYXBwaW5nS2V5LmNvcHkoW1wiZGVjcnlwdFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHVud3JhcEFsZ29yaXRobSwgY29weUtleSwgd3JhcHBlZEtleSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGRhdGFBbnk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhQW55ID0gSlNPTi5wYXJzZShoZWxwZXJfMS5idWZmZXIyc3RyaW5nKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhQW55ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoZm9ybWF0LCBkYXRhQW55LCB1bndyYXBwZWRLZXlBbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFlc0NyeXB0by5hbGcyandrID0gZnVuY3Rpb24gKGFsZykge1xuICAgICAgICByZXR1cm4gXCJBXCIgKyBhbGcubGVuZ3RoICsgLy0oXFx3KykvaS5leGVjKGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkpWzFdO1xuICAgIH07XG4gICAgQWVzQ3J5cHRvLmp3azJhbGcgPSBmdW5jdGlvbiAoYWxnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuICAgIEFlc0NyeXB0by5leHBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmF3ID0ga2V5LmtleTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgICAgIHZhciBqd2sgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZzogX3RoaXMuYWxnMmp3ayhrZXkuYWxnb3JpdGhtKSxcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBrZXkuZXh0cmFjdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGs6IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmVuY29kZShyYXcpLFxuICAgICAgICAgICAgICAgICAgICBrZXlfb3BzOiBrZXkudXNhZ2VzLFxuICAgICAgICAgICAgICAgICAgICBrdHk6IFwib2N0XCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gandrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhdy5idWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWVzQ3J5cHRvLmltcG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIHVzYWdlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmF3LCBqd2ssIGtleTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgandrID0ga2V5RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gd2ViY3J5cHRvX2NvcmVfMS5CYXNlNjRVcmwuZGVjb2RlKGp3ay5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdyA9IG5ldyBVaW50OEFycmF5KGtleURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcga2V5XzEuQ3J5cHRvS2V5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZWNyZXRcIixcbiAgICAgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RhYmxlOiBleHRyYWN0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2VzOiB1c2FnZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAga2V5LmtleSA9IHJhdztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywga2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFlc0NyeXB0by5jaGVja01vZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhc21DcnlwdG8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLk1PRFVMRV9OT1RfRk9VTkQsIFwiYXNtQ3J5cHRvXCIsIFwiaHR0cHM6Ly9naXRodWIuY29tL3ZpYm9ybm9mZi9hc21jcnlwdG8uanNcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBZXNDcnlwdG87XG59KHdlYmNyeXB0b19jb3JlXzEuQmFzZUNyeXB0bykpO1xuZXhwb3J0cy5BZXNDcnlwdG8gPSBBZXNDcnlwdG87XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/aes/crypto.ts\n");

/***/ }),

/***/ "./src/crypto.ts":
/*!***********************!*\
  !*** ./src/crypto.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar subtle_1 = __webpack_require__(/*! ./subtle */ \"./src/subtle.ts\");\nvar init_1 = __webpack_require__(/*! ./init */ \"./src/init.ts\");\nvar Crypto = /** @class */ (function () {\n    function Crypto() {\n        this.subtle = new subtle_1.SubtleCrypto();\n    }\n    Crypto.prototype.getRandomValues = function (array) {\n        return init_1.nativeCrypto.getRandomValues(array);\n    };\n    return Crypto;\n}());\nexports.Crypto = Crypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3J5cHRvLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvLi9zcmMvY3J5cHRvLnRzP2JiMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3VidGxlXzEgPSByZXF1aXJlKFwiLi9zdWJ0bGVcIik7XG52YXIgaW5pdF8xID0gcmVxdWlyZShcIi4vaW5pdFwiKTtcbnZhciBDcnlwdG8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3J5cHRvKCkge1xuICAgICAgICB0aGlzLnN1YnRsZSA9IG5ldyBzdWJ0bGVfMS5TdWJ0bGVDcnlwdG8oKTtcbiAgICB9XG4gICAgQ3J5cHRvLnByb3RvdHlwZS5nZXRSYW5kb21WYWx1ZXMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRfMS5uYXRpdmVDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICB9O1xuICAgIHJldHVybiBDcnlwdG87XG59KCkpO1xuZXhwb3J0cy5DcnlwdG8gPSBDcnlwdG87XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/crypto.ts\n");

/***/ }),

/***/ "./src/ec/crypto.ts":
/*!**************************!*\
  !*** ./src/ec/crypto.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar webcrypto_core_1 = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\nvar error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nvar key_1 = __webpack_require__(/*! ../key */ \"./src/key.ts\");\nvar helper_1 = __webpack_require__(/*! ../helper */ \"./src/helper.ts\");\nvar crypto_1 = __webpack_require__(/*! ../crypto */ \"./src/crypto.ts\");\n// Helper\nfunction b2a(buffer) {\n    var buf = new Uint8Array(buffer);\n    var res = [];\n    // tslint:disable-next-line:prefer-for-of\n    for (var i = 0; i < buf.length; i++) {\n        res.push(buf[i]);\n    }\n    return res;\n}\nfunction hex2buffer(hexString, padded) {\n    if (hexString.length % 2) {\n        hexString = \"0\" + hexString;\n    }\n    var res = new Uint8Array(hexString.length / 2);\n    for (var i = 0; i < hexString.length; i++) {\n        var c = hexString.slice(i, ++i + 1);\n        res[(i - 1) / 2] = parseInt(c, 16);\n    }\n    // BN padding\n    if (padded) {\n        var len = res.length;\n        len = len > 32 ? len > 48 ? 66 : 48 : 32;\n        if (res.length < len) {\n            res = helper_1.concat(new Uint8Array(len - res.length), res);\n        }\n    }\n    return res;\n}\nfunction buffer2hex(buffer, padded) {\n    var res = \"\";\n    // tslint:disable-next-line:prefer-for-of\n    for (var i = 0; i < buffer.length; i++) {\n        var char = buffer[i].toString(16);\n        res += char.length % 2 ? \"0\" + char : char;\n    }\n    // BN padding\n    if (padded) {\n        var len = buffer.length;\n        len = len > 32 ? len > 48 ? 66 : 48 : 32;\n        if ((res.length / 2) < len) {\n            res = new Array(len * 2 - res.length + 1).join(\"0\") + res;\n        }\n    }\n    return res;\n}\nvar EcCrypto = /** @class */ (function (_super) {\n    __extends(EcCrypto, _super);\n    function EcCrypto() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    EcCrypto.generateKey = function (algorithm, extractable, keyUsage) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            _this.checkModule();\n            var alg = algorithm;\n            var key = new elliptic.ec(_this.getNamedCurve(algorithm.namedCurve));\n            // set key params\n            var prvKey = new key_1.CryptoKey({\n                type: \"private\",\n                algorithm: algorithm,\n                extractable: extractable,\n                usages: [],\n            });\n            var pubKey = new key_1.CryptoKey({\n                type: \"public\",\n                algorithm: algorithm,\n                extractable: true,\n                usages: [],\n            });\n            prvKey.key = pubKey.key = key.genKeyPair();\n            if (algorithm.name === webcrypto_core_1.AlgorithmNames.EcDSA) {\n                prvKey.usages = [\"sign\"];\n                pubKey.usages = [\"verify\"];\n            }\n            else if (algorithm.name === webcrypto_core_1.AlgorithmNames.EcDH) {\n                prvKey.usages = [\"deriveKey\", \"deriveBits\"];\n                pubKey.usages = [];\n            }\n            else if (algorithm.name === webcrypto_core_1.AlgorithmNames.EdDSA) {\n                prvKey.usages = [\"sign\"];\n                pubKey.usages = [\"verify\"];\n            }\n            return {\n                privateKey: prvKey,\n                publicKey: pubKey,\n            };\n        });\n    };\n    EcCrypto.sign = function (algorithm, key, data) {\n        return __awaiter(this, void 0, void 0, function () {\n            var alg, crypto, array, hash, signature, hexSignature;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        alg = algorithm;\n                        crypto = new crypto_1.Crypto();\n                        if (!(algorithm.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.EdDSA)) return [3 /*break*/, 2];\n                        array = data;\n                        return [4 /*yield*/, key.key.sign(array).toBytes()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2: return [4 /*yield*/, crypto.subtle.digest(alg.hash, data)];\n                    case 3:\n                        hash = _a.sent();\n                        array = b2a(hash);\n                        return [4 /*yield*/, key.key.sign(array)];\n                    case 4:\n                        signature = _a.sent();\n                        hexSignature = buffer2hex(signature.r.toArray(), true) + buffer2hex(signature.s.toArray(), true);\n                        return [2 /*return*/, hex2buffer(hexSignature).buffer];\n                }\n            });\n        });\n    };\n    EcCrypto.verify = function (algorithm, key, signature, data) {\n        return __awaiter(this, void 0, void 0, function () {\n            var alg, hashedData, sig, crypto_2, array;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        alg = algorithm;\n                        if (!(algorithm.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.EdDSA)) return [3 /*break*/, 1];\n                        sig = b2a(signature);\n                        hashedData = data.buffer;\n                        return [3 /*break*/, 3];\n                    case 1:\n                        sig = {\n                            r: signature.slice(0, signature.byteLength / 2),\n                            s: signature.slice(signature.byteLength / 2),\n                        };\n                        crypto_2 = new crypto_1.Crypto();\n                        return [4 /*yield*/, crypto_2.subtle.digest(alg.hash, data)];\n                    case 2:\n                        hashedData = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        array = b2a(hashedData);\n                        return [2 /*return*/, (key.key.verify(array, sig))];\n                }\n            });\n        });\n    };\n    EcCrypto.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.deriveBits(algorithm, baseKey, derivedKeyType.length);\n        })\n            .then(function (bits) {\n            var crypto = new crypto_1.Crypto();\n            return crypto.subtle.importKey(\"raw\", new Uint8Array(bits), derivedKeyType, extractable, keyUsages);\n        });\n    };\n    EcCrypto.deriveBits = function (algorithm, baseKey, length) {\n        return Promise.resolve()\n            .then(function () {\n            var promise = Promise.resolve(null);\n            var shared = baseKey.key.derive(algorithm.public.key.getPublic());\n            var array = new Uint8Array(shared.toArray());\n            // Padding\n            var len = array.length;\n            len = (len > 32 ? (len > 48 ? 66 : 48) : 32);\n            if (array.length < len) {\n                array = helper_1.concat(new Uint8Array(len - array.length), array);\n            }\n            var buf = array.slice(0, length / 8).buffer;\n            return buf;\n        });\n    };\n    EcCrypto.exportKey = function (format, key) {\n        return Promise.resolve()\n            .then(function () {\n            var ecKey = key.key;\n            if (format.toLowerCase() === \"jwk\") {\n                var hexPub = ecKey.getPublic(\"hex\").slice(2); // ignore first '04'\n                var hexX = hexPub.slice(0, hexPub.length / 2);\n                var hexY = hexPub.slice(hexPub.length / 2, hexPub.length);\n                if (key.type === \"public\") {\n                    // public\n                    var jwk = {\n                        crv: key.algorithm.namedCurve,\n                        ext: key.extractable,\n                        x: webcrypto_core_1.Base64Url.encode(hex2buffer(hexX, true)),\n                        y: webcrypto_core_1.Base64Url.encode(hex2buffer(hexY, true)),\n                        key_ops: key.usages,\n                        kty: \"EC\",\n                    };\n                    return jwk;\n                }\n                else {\n                    // private\n                    var jwk = {\n                        crv: key.algorithm.namedCurve,\n                        ext: key.extractable,\n                        d: webcrypto_core_1.Base64Url.encode(hex2buffer(ecKey.getPrivate(\"hex\"), true)),\n                        x: webcrypto_core_1.Base64Url.encode(hex2buffer(hexX, true)),\n                        y: webcrypto_core_1.Base64Url.encode(hex2buffer(hexY, true)),\n                        key_ops: key.usages,\n                        kty: \"EC\",\n                    };\n                    return jwk;\n                }\n            }\n            else {\n                throw new error_1.LinerError(\"Format '\" + format + \"' is not implemented\");\n            }\n        });\n    };\n    EcCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            var key = new key_1.CryptoKey({\n                algorithm: algorithm,\n                extractable: extractable,\n                usages: keyUsages,\n            });\n            if (format.toLowerCase() === \"jwk\") {\n                var namedCurve = _this.getNamedCurve(algorithm.namedCurve);\n                console.log(namedCurve);\n                var ecKey = void 0;\n                if (algorithm.name.toLowerCase() === \"eddsa\") {\n                    ecKey = new elliptic.eddsa(namedCurve);\n                }\n                else {\n                    ecKey = new elliptic.ec(namedCurve);\n                }\n                if (keyData.d) {\n                    // Private key\n                    if (algorithm.name.toLowerCase() === \"eddsa\") {\n                        key.key = ecKey.keyFromSecret(webcrypto_core_1.Base64Url.decode(keyData.d));\n                    }\n                    else {\n                        key.key = ecKey.keyFromPrivate(webcrypto_core_1.Base64Url.decode(keyData.d));\n                    }\n                    key.type = \"private\";\n                }\n                else {\n                    var bufferPubKey = void 0;\n                    if (namedCurve === \"ed25519\" || namedCurve === \"curve25519\") {\n                        bufferPubKey = webcrypto_core_1.Base64Url.decode(keyData.x);\n                    }\n                    else {\n                        bufferPubKey = helper_1.concat(new Uint8Array([4]), webcrypto_core_1.Base64Url.decode(keyData.x), webcrypto_core_1.Base64Url.decode(keyData.y));\n                    }\n                    var hexPubKey = buffer2hex(bufferPubKey);\n                    key.key = ecKey.keyFromPublic(hexPubKey, \"hex\");\n                    key.type = \"public\";\n                }\n            }\n            else {\n                throw new error_1.LinerError(\"Format '\" + format + \"' is not implemented\");\n            }\n            return key;\n        });\n    };\n    EcCrypto.checkModule = function () {\n        if (typeof elliptic === \"undefined\") {\n            throw new error_1.LinerError(error_1.LinerError.MODULE_NOT_FOUND, \"elliptic\", \"https://github.com/indutny/elliptic\");\n        }\n    };\n    EcCrypto.getNamedCurve = function (wcNamedCurve) {\n        var crv = wcNamedCurve.toUpperCase();\n        var res = \"\";\n        if ([\"P-256\", \"P-384\", \"P-521\", \"ED25519\"].indexOf(crv) > -1) {\n            res = crv.replace(\"-\", \"\").toLowerCase();\n        }\n        else if (crv === \"K-256\") {\n            res = \"secp256k1\";\n        }\n        else if (\"X25519\") {\n            res = \"curve25519\";\n        }\n        else {}\n        return res;\n    };\n    return EcCrypto;\n}(webcrypto_core_1.BaseCrypto));\nexports.EcCrypto = EcCrypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZWMvY3J5cHRvLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvLi9zcmMvZWMvY3J5cHRvLnRzPzI3MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdlYmNyeXB0b19jb3JlXzEgPSByZXF1aXJlKFwid2ViY3J5cHRvLWNvcmVcIik7XG52YXIgZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcbnZhciBrZXlfMSA9IHJlcXVpcmUoXCIuLi9rZXlcIik7XG52YXIgaGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVyXCIpO1xudmFyIGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0b1wiKTtcbi8vIEhlbHBlclxuZnVuY3Rpb24gYjJhKGJ1ZmZlcikge1xuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWZvci1vZlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcy5wdXNoKGJ1ZltpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBoZXgyYnVmZmVyKGhleFN0cmluZywgcGFkZGVkKSB7XG4gICAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyKSB7XG4gICAgICAgIGhleFN0cmluZyA9IFwiMFwiICsgaGV4U3RyaW5nO1xuICAgIH1cbiAgICB2YXIgcmVzID0gbmV3IFVpbnQ4QXJyYXkoaGV4U3RyaW5nLmxlbmd0aCAvIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gaGV4U3RyaW5nLnNsaWNlKGksICsraSArIDEpO1xuICAgICAgICByZXNbKGkgLSAxKSAvIDJdID0gcGFyc2VJbnQoYywgMTYpO1xuICAgIH1cbiAgICAvLyBCTiBwYWRkaW5nXG4gICAgaWYgKHBhZGRlZCkge1xuICAgICAgICB2YXIgbGVuID0gcmVzLmxlbmd0aDtcbiAgICAgICAgbGVuID0gbGVuID4gMzIgPyBsZW4gPiA0OCA/IDY2IDogNDggOiAzMjtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICAgIHJlcyA9IGhlbHBlcl8xLmNvbmNhdChuZXcgVWludDhBcnJheShsZW4gLSByZXMubGVuZ3RoKSwgcmVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYnVmZmVyMmhleChidWZmZXIsIHBhZGRlZCkge1xuICAgIHZhciByZXMgPSBcIlwiO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItZm9yLW9mXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXIgPSBidWZmZXJbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICByZXMgKz0gY2hhci5sZW5ndGggJSAyID8gXCIwXCIgKyBjaGFyIDogY2hhcjtcbiAgICB9XG4gICAgLy8gQk4gcGFkZGluZ1xuICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGxlbiA9IGxlbiA+IDMyID8gbGVuID4gNDggPyA2NiA6IDQ4IDogMzI7XG4gICAgICAgIGlmICgocmVzLmxlbmd0aCAvIDIpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXMgPSBuZXcgQXJyYXkobGVuICogMiAtIHJlcy5sZW5ndGggKyAxKS5qb2luKFwiMFwiKSArIHJlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxudmFyIEVjQ3J5cHRvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFY0NyeXB0bywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFY0NyeXB0bygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFY0NyeXB0by5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNoZWNrTW9kdWxlKCk7XG4gICAgICAgICAgICB2YXIgYWxnID0gYWxnb3JpdGhtO1xuICAgICAgICAgICAgdmFyIGtleSA9IG5ldyBlbGxpcHRpYy5lYyhfdGhpcy5nZXROYW1lZEN1cnZlKGFsZ29yaXRobS5uYW1lZEN1cnZlKSk7XG4gICAgICAgICAgICAvLyBzZXQga2V5IHBhcmFtc1xuICAgICAgICAgICAgdmFyIHBydktleSA9IG5ldyBrZXlfMS5DcnlwdG9LZXkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicHJpdmF0ZVwiLFxuICAgICAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgIGV4dHJhY3RhYmxlOiBleHRyYWN0YWJsZSxcbiAgICAgICAgICAgICAgICB1c2FnZXM6IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcHViS2V5ID0gbmV3IGtleV8xLkNyeXB0b0tleSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJwdWJsaWNcIixcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IGFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICBleHRyYWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2FnZXM6IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcnZLZXkua2V5ID0gcHViS2V5LmtleSA9IGtleS5nZW5LZXlQYWlyKCk7XG4gICAgICAgICAgICBpZiAoYWxnb3JpdGhtLm5hbWUgPT09IHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuRWNEU0EpIHtcbiAgICAgICAgICAgICAgICBwcnZLZXkudXNhZ2VzID0gW1wic2lnblwiXTtcbiAgICAgICAgICAgICAgICBwdWJLZXkudXNhZ2VzID0gW1widmVyaWZ5XCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWxnb3JpdGhtLm5hbWUgPT09IHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuRWNESCkge1xuICAgICAgICAgICAgICAgIHBydktleS51c2FnZXMgPSBbXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuICAgICAgICAgICAgICAgIHB1YktleS51c2FnZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFsZ29yaXRobS5uYW1lID09PSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVkRFNBKSB7XG4gICAgICAgICAgICAgICAgcHJ2S2V5LnVzYWdlcyA9IFtcInNpZ25cIl07XG4gICAgICAgICAgICAgICAgcHViS2V5LnVzYWdlcyA9IFtcInZlcmlmeVwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJ2S2V5LFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleTogcHViS2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFY0NyeXB0by5zaWduID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhbGcsIGNyeXB0bywgYXJyYXksIGhhc2gsIHNpZ25hdHVyZSwgaGV4U2lnbmF0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxnID0gYWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvID0gbmV3IGNyeXB0b18xLkNyeXB0bygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5FZERTQSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywga2V5LmtleS5zaWduKGFycmF5KS50b0J5dGVzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIGNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZy5oYXNoLCBkYXRhKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheSA9IGIyYShoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGtleS5rZXkuc2lnbihhcnJheSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXhTaWduYXR1cmUgPSBidWZmZXIyaGV4KHNpZ25hdHVyZS5yLnRvQXJyYXkoKSwgdHJ1ZSkgKyBidWZmZXIyaGV4KHNpZ25hdHVyZS5zLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaGV4MmJ1ZmZlcihoZXhTaWduYXR1cmUpLmJ1ZmZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWNDcnlwdG8udmVyaWZ5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFsZywgaGFzaGVkRGF0YSwgc2lnLCBjcnlwdG9fMiwgYXJyYXk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGcgPSBhbGdvcml0aG07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVkRFNBKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWcgPSBiMmEoc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hlZERhdGEgPSBkYXRhLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogc2lnbmF0dXJlLnNsaWNlKDAsIHNpZ25hdHVyZS5ieXRlTGVuZ3RoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczogc2lnbmF0dXJlLnNsaWNlKHNpZ25hdHVyZS5ieXRlTGVuZ3RoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3J5cHRvXzIgPSBuZXcgY3J5cHRvXzEuQ3J5cHRvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjcnlwdG9fMi5zdWJ0bGUuZGlnZXN0KGFsZy5oYXNoLCBkYXRhKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hlZERhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gYjJhKGhhc2hlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChrZXkua2V5LnZlcmlmeShhcnJheSwgc2lnKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVjQ3J5cHRvLmRlcml2ZUtleSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGJhc2VLZXksIGRlcml2ZWRLZXlUeXBlLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZS5sZW5ndGgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJpdHMpIHtcbiAgICAgICAgICAgIHZhciBjcnlwdG8gPSBuZXcgY3J5cHRvXzEuQ3J5cHRvKCk7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgbmV3IFVpbnQ4QXJyYXkoYml0cyksIGRlcml2ZWRLZXlUeXBlLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFY0NyeXB0by5kZXJpdmVCaXRzID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB2YXIgc2hhcmVkID0gYmFzZUtleS5rZXkuZGVyaXZlKGFsZ29yaXRobS5wdWJsaWMua2V5LmdldFB1YmxpYygpKTtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KHNoYXJlZC50b0FycmF5KCkpO1xuICAgICAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIGxlbiA9IChsZW4gPiAzMiA/IChsZW4gPiA0OCA/IDY2IDogNDgpIDogMzIpO1xuICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGFycmF5ID0gaGVscGVyXzEuY29uY2F0KG5ldyBVaW50OEFycmF5KGxlbiAtIGFycmF5Lmxlbmd0aCksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBidWYgPSBhcnJheS5zbGljZSgwLCBsZW5ndGggLyA4KS5idWZmZXI7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVjQ3J5cHRvLmV4cG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlY0tleSA9IGtleS5rZXk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGV4UHViID0gZWNLZXkuZ2V0UHVibGljKFwiaGV4XCIpLnNsaWNlKDIpOyAvLyBpZ25vcmUgZmlyc3QgJzA0J1xuICAgICAgICAgICAgICAgIHZhciBoZXhYID0gaGV4UHViLnNsaWNlKDAsIGhleFB1Yi5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgaGV4WSA9IGhleFB1Yi5zbGljZShoZXhQdWIubGVuZ3RoIC8gMiwgaGV4UHViLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1YmxpY1xuICAgICAgICAgICAgICAgICAgICB2YXIgandrID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3J2OiBrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHQ6IGtleS5leHRyYWN0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmVuY29kZShoZXgyYnVmZmVyKGhleFgsIHRydWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmVuY29kZShoZXgyYnVmZmVyKGhleFksIHRydWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleV9vcHM6IGtleS51c2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrdHk6IFwiRUNcIixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGp3aztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGp3ayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNydjoga2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0OiBrZXkuZXh0cmFjdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkOiB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5lbmNvZGUoaGV4MmJ1ZmZlcihlY0tleS5nZXRQcml2YXRlKFwiaGV4XCIpLCB0cnVlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5lbmNvZGUoaGV4MmJ1ZmZlcihoZXhYLCB0cnVlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5lbmNvZGUoaGV4MmJ1ZmZlcihoZXhZLCB0cnVlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlfb3BzOiBrZXkudXNhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAga3R5OiBcIkVDXCIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihcIkZvcm1hdCAnXCIgKyBmb3JtYXQgKyBcIicgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVjQ3J5cHRvLmltcG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBuZXcga2V5XzEuQ3J5cHRvS2V5KHtcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IGFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICBleHRyYWN0YWJsZTogZXh0cmFjdGFibGUsXG4gICAgICAgICAgICAgICAgdXNhZ2VzOiBrZXlVc2FnZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lZEN1cnZlID0gX3RoaXMuZ2V0TmFtZWRDdXJ2ZShhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZWRDdXJ2ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVjS2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImVkZHNhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWNLZXkgPSBuZXcgZWxsaXB0aWMuZWRkc2EobmFtZWRDdXJ2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlY0tleSA9IG5ldyBlbGxpcHRpYy5lYyhuYW1lZEN1cnZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleURhdGEuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcml2YXRlIGtleVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJlZGRzYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkua2V5ID0gZWNLZXkua2V5RnJvbVNlY3JldCh3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5kZWNvZGUoa2V5RGF0YS5kKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkua2V5ID0gZWNLZXkua2V5RnJvbVByaXZhdGUod2ViY3J5cHRvX2NvcmVfMS5CYXNlNjRVcmwuZGVjb2RlKGtleURhdGEuZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGtleS50eXBlID0gXCJwcml2YXRlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyUHViS2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZWRDdXJ2ZSA9PT0gXCJlZDI1NTE5XCIgfHwgbmFtZWRDdXJ2ZSA9PT0gXCJjdXJ2ZTI1NTE5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclB1YktleSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmRlY29kZShrZXlEYXRhLngpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyUHViS2V5ID0gaGVscGVyXzEuY29uY2F0KG5ldyBVaW50OEFycmF5KFs0XSksIHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmRlY29kZShrZXlEYXRhLngpLCB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5kZWNvZGUoa2V5RGF0YS55KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhleFB1YktleSA9IGJ1ZmZlcjJoZXgoYnVmZmVyUHViS2V5KTtcbiAgICAgICAgICAgICAgICAgICAga2V5LmtleSA9IGVjS2V5LmtleUZyb21QdWJsaWMoaGV4UHViS2V5LCBcImhleFwiKTtcbiAgICAgICAgICAgICAgICAgICAga2V5LnR5cGUgPSBcInB1YmxpY1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoXCJGb3JtYXQgJ1wiICsgZm9ybWF0ICsgXCInIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWNDcnlwdG8uY2hlY2tNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxsaXB0aWMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLk1PRFVMRV9OT1RfRk9VTkQsIFwiZWxsaXB0aWNcIiwgXCJodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpY1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWNDcnlwdG8uZ2V0TmFtZWRDdXJ2ZSA9IGZ1bmN0aW9uICh3Y05hbWVkQ3VydmUpIHtcbiAgICAgICAgdmFyIGNydiA9IHdjTmFtZWRDdXJ2ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgICAgaWYgKFtcIlAtMjU2XCIsIFwiUC0zODRcIiwgXCJQLTUyMVwiLCBcIkVEMjU1MTlcIl0uaW5kZXhPZihjcnYpID4gLTEpIHtcbiAgICAgICAgICAgIHJlcyA9IGNydi5yZXBsYWNlKFwiLVwiLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNydiA9PT0gXCJLLTI1NlwiKSB7XG4gICAgICAgICAgICByZXMgPSBcInNlY3AyNTZrMVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiWDI1NTE5XCIpIHtcbiAgICAgICAgICAgIHJlcyA9IFwiY3VydmUyNTUxOVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihcIlVuc3VwcG9ydGVkIG5hbWVkIGN1cnZlICdcIiArIHdjTmFtZWRDdXJ2ZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIEVjQ3J5cHRvO1xufSh3ZWJjcnlwdG9fY29yZV8xLkJhc2VDcnlwdG8pKTtcbmV4cG9ydHMuRWNDcnlwdG8gPSBFY0NyeXB0bztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/ec/crypto.ts\n");

/***/ }),

/***/ "./src/error.ts":
/*!**********************!*\
  !*** ./src/error.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar webcrypto_core_1 = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\nvar LinerError = /** @class */ (function (_super) {\n    __extends(LinerError, _super);\n    function LinerError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.code = 10;\n        return _this;\n    }\n    LinerError.MODULE_NOT_FOUND = \"Module '%1' is not found. Download it from %2\";\n    LinerError.UNSUPPORTED_ALGORITHM = \"Unsupported algorithm '%1'\";\n    return LinerError;\n}(webcrypto_core_1.WebCryptoError));\nexports.LinerError = LinerError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZXJyb3IudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lci8uL3NyYy9lcnJvci50cz9hZmI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2ViY3J5cHRvX2NvcmVfMSA9IHJlcXVpcmUoXCJ3ZWJjcnlwdG8tY29yZVwiKTtcbnZhciBMaW5lckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5lckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmVyRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2RlID0gMTA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGluZXJFcnJvci5NT0RVTEVfTk9UX0ZPVU5EID0gXCJNb2R1bGUgJyUxJyBpcyBub3QgZm91bmQuIERvd25sb2FkIGl0IGZyb20gJTJcIjtcbiAgICBMaW5lckVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSA9IFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtICclMSdcIjtcbiAgICByZXR1cm4gTGluZXJFcnJvcjtcbn0od2ViY3J5cHRvX2NvcmVfMS5XZWJDcnlwdG9FcnJvcikpO1xuZXhwb3J0cy5MaW5lckVycm9yID0gTGluZXJFcnJvcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/error.ts\n");

/***/ }),

/***/ "./src/helper.ts":
/*!***********************!*\
  !*** ./src/helper.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Browser = {\n    IE: \"Internet Explorer\",\n    Safari: \"Safari\",\n    Edge: \"Edge\",\n    Chrome: \"Chrome\",\n    Firefox: \"Firefox Mozilla\",\n    Mobile: \"Mobile\",\n};\n/**\n * Returns info about browser\n */\nfunction BrowserInfo() {\n    var res = {\n        name: \"Unknown\",\n        version: \"0\",\n    };\n    var userAgent = self.navigator.userAgent;\n    var reg;\n    // tslint:disable-next-line:no-conditional-assignment\n    if (reg = /edge\\/([\\d\\.]+)/i.exec(userAgent)) {\n        res.name = exports.Browser.Edge;\n        res.version = reg[1];\n    }\n    else if (/msie/i.test(userAgent)) {\n        res.name = exports.Browser.IE;\n        res.version = /msie ([\\d\\.]+)/i.exec(userAgent)[1];\n    }\n    else if (/Trident/i.test(userAgent)) {\n        res.name = exports.Browser.IE;\n        res.version = /rv:([\\d\\.]+)/i.exec(userAgent)[1];\n    }\n    else if (/chrome/i.test(userAgent)) {\n        res.name = exports.Browser.Chrome;\n        res.version = /chrome\\/([\\d\\.]+)/i.exec(userAgent)[1];\n    }\n    else if (/firefox/i.test(userAgent)) {\n        res.name = exports.Browser.Firefox;\n        res.version = /firefox\\/([\\d\\.]+)/i.exec(userAgent)[1];\n    }\n    else if (/mobile/i.test(userAgent)) {\n        res.name = exports.Browser.Mobile;\n        res.version = /mobile\\/([\\w]+)/i.exec(userAgent)[1];\n    }\n    else if (/safari/i.test(userAgent)) {\n        res.name = exports.Browser.Safari;\n        res.version = /version\\/([\\d\\.]+)/i.exec(userAgent)[1];\n    }\n    return res;\n}\nexports.BrowserInfo = BrowserInfo;\nfunction string2buffer(binaryString) {\n    var res = new Uint8Array(binaryString.length);\n    for (var i = 0; i < binaryString.length; i++) {\n        res[i] = binaryString.charCodeAt(i);\n    }\n    return res;\n}\nexports.string2buffer = string2buffer;\nfunction buffer2string(buffer) {\n    var res = \"\";\n    // tslint:disable-next-line:prefer-for-of\n    for (var i = 0; i < buffer.length; i++) {\n        res += String.fromCharCode(buffer[i]);\n    }\n    return res;\n}\nexports.buffer2string = buffer2string;\nfunction concat() {\n    var buf = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        buf[_i] = arguments[_i];\n    }\n    var res = new Uint8Array(buf.map(function (item) { return item.length; }).reduce(function (prev, cur) { return prev + cur; }));\n    var offset = 0;\n    buf.forEach(function (item, index) {\n        for (var i = 0; i < item.length; i++) {\n            res[offset + i] = item[i];\n        }\n        offset += item.length;\n    });\n    return res;\n}\nexports.concat = concat;\nfunction assign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    var res = arguments[0];\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        for (var prop in obj) {\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nexports.assign = assign;\nfunction warn(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    if (typeof self !== \"undefined\" && self.PV_WEBCRYPTO_LINER_LOG) {\n        console.warn.apply(console, arguments);\n    }\n}\nexports.warn = warn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvLi9zcmMvaGVscGVyLnRzPzc5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXIgPSB7XG4gICAgSUU6IFwiSW50ZXJuZXQgRXhwbG9yZXJcIixcbiAgICBTYWZhcmk6IFwiU2FmYXJpXCIsXG4gICAgRWRnZTogXCJFZGdlXCIsXG4gICAgQ2hyb21lOiBcIkNocm9tZVwiLFxuICAgIEZpcmVmb3g6IFwiRmlyZWZveCBNb3ppbGxhXCIsXG4gICAgTW9iaWxlOiBcIk1vYmlsZVwiLFxufTtcbi8qKlxuICogUmV0dXJucyBpbmZvIGFib3V0IGJyb3dzZXJcbiAqL1xuZnVuY3Rpb24gQnJvd3NlckluZm8oKSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgbmFtZTogXCJVbmtub3duXCIsXG4gICAgICAgIHZlcnNpb246IFwiMFwiLFxuICAgIH07XG4gICAgdmFyIHVzZXJBZ2VudCA9IHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB2YXIgcmVnO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgaWYgKHJlZyA9IC9lZGdlXFwvKFtcXGRcXC5dKykvaS5leGVjKHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmVzLm5hbWUgPSBleHBvcnRzLkJyb3dzZXIuRWRnZTtcbiAgICAgICAgcmVzLnZlcnNpb24gPSByZWdbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKC9tc2llL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJlcy5uYW1lID0gZXhwb3J0cy5Ccm93c2VyLklFO1xuICAgICAgICByZXMudmVyc2lvbiA9IC9tc2llIChbXFxkXFwuXSspL2kuZXhlYyh1c2VyQWdlbnQpWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmICgvVHJpZGVudC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgICByZXMubmFtZSA9IGV4cG9ydHMuQnJvd3Nlci5JRTtcbiAgICAgICAgcmVzLnZlcnNpb24gPSAvcnY6KFtcXGRcXC5dKykvaS5leGVjKHVzZXJBZ2VudClbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKC9jaHJvbWUvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmVzLm5hbWUgPSBleHBvcnRzLkJyb3dzZXIuQ2hyb21lO1xuICAgICAgICByZXMudmVyc2lvbiA9IC9jaHJvbWVcXC8oW1xcZFxcLl0rKS9pLmV4ZWModXNlckFnZW50KVsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmVzLm5hbWUgPSBleHBvcnRzLkJyb3dzZXIuRmlyZWZveDtcbiAgICAgICAgcmVzLnZlcnNpb24gPSAvZmlyZWZveFxcLyhbXFxkXFwuXSspL2kuZXhlYyh1c2VyQWdlbnQpWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmICgvbW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJlcy5uYW1lID0gZXhwb3J0cy5Ccm93c2VyLk1vYmlsZTtcbiAgICAgICAgcmVzLnZlcnNpb24gPSAvbW9iaWxlXFwvKFtcXHddKykvaS5leGVjKHVzZXJBZ2VudClbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKC9zYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmVzLm5hbWUgPSBleHBvcnRzLkJyb3dzZXIuU2FmYXJpO1xuICAgICAgICByZXMudmVyc2lvbiA9IC92ZXJzaW9uXFwvKFtcXGRcXC5dKykvaS5leGVjKHVzZXJBZ2VudClbMV07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLkJyb3dzZXJJbmZvID0gQnJvd3NlckluZm87XG5mdW5jdGlvbiBzdHJpbmcyYnVmZmVyKGJpbmFyeVN0cmluZykge1xuICAgIHZhciByZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuc3RyaW5nMmJ1ZmZlciA9IHN0cmluZzJidWZmZXI7XG5mdW5jdGlvbiBidWZmZXIyc3RyaW5nKGJ1ZmZlcikge1xuICAgIHZhciByZXMgPSBcIlwiO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItZm9yLW9mXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuYnVmZmVyMnN0cmluZyA9IGJ1ZmZlcjJzdHJpbmc7XG5mdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGJ1ZltfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5sZW5ndGg7IH0pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7IHJldHVybiBwcmV2ICsgY3VyOyB9KSk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgYnVmLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzW29mZnNldCArIGldID0gaXRlbVtpXTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gaXRlbS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmVzW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmFzc2lnbiA9IGFzc2lnbjtcbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbmFsUGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5QVl9XRUJDUllQVE9fTElORVJfTE9HKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbn1cbmV4cG9ydHMud2FybiA9IHdhcm47XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/helper.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./init */ \"./src/init.ts\"));\n__export(__webpack_require__(/*! ./crypto */ \"./src/crypto.ts\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lci8uL3NyYy9pbmRleC50cz83MWJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2luaXRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY3J5cHRvXCIpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./src/init.ts":
/*!*********************!*\
  !*** ./src/init.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/error.ts\");\nvar w;\nif (typeof self === \"undefined\") {\n    var crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\n    w = {\n        crypto: {\n            subtle: {},\n            getRandomValues: function (array) {\n                var buf = array.buffer;\n                var uint8buf = new Uint8Array(buf);\n                var rnd = crypto_1.randomBytes(uint8buf.length);\n                rnd.forEach(function (octet, index) { return uint8buf[index] = octet; });\n                return array;\n            },\n        },\n    };\n}\nelse {\n    w = self;\n}\nexports.nativeCrypto = w.msCrypto || w.crypto || {};\nexports.nativeSubtle = null;\ntry {\n    exports.nativeSubtle = exports.nativeCrypto.subtle || exports.nativeCrypto.webkitSubtle;\n}\ncatch (err) {\n    // Safari throws error on crypto.webkitSubtle in Worker\n}\nfunction WrapFunction(subtle, name) {\n    var fn = subtle[name];\n    // tslint:disable-next-line:only-arrow-functions\n    subtle[name] = function () {\n        var args = arguments;\n        return new Promise(function (resolve, reject) {\n            var op = fn.apply(subtle, args);\n            op.oncomplete = function (e) {\n                resolve(e.target.result);\n            };\n            op.onerror = function (e) {\n                reject(\"Error on running '\" + name + \"' function\");\n            };\n        });\n    };\n}\nif (w.msCrypto) {\n    if (!w.Promise) {\n        throw new error_1.LinerError(error_1.LinerError.MODULE_NOT_FOUND, \"Promise\", \"https://www.promisejs.org\");\n    }\n    WrapFunction(exports.nativeSubtle, \"generateKey\");\n    WrapFunction(exports.nativeSubtle, \"digest\");\n    WrapFunction(exports.nativeSubtle, \"sign\");\n    WrapFunction(exports.nativeSubtle, \"verify\");\n    WrapFunction(exports.nativeSubtle, \"encrypt\");\n    WrapFunction(exports.nativeSubtle, \"decrypt\");\n    WrapFunction(exports.nativeSubtle, \"importKey\");\n    WrapFunction(exports.nativeSubtle, \"exportKey\");\n    WrapFunction(exports.nativeSubtle, \"wrapKey\");\n    WrapFunction(exports.nativeSubtle, \"unwrapKey\");\n    WrapFunction(exports.nativeSubtle, \"deriveKey\");\n    WrapFunction(exports.nativeSubtle, \"deriveBits\");\n}\n// fix: Math.imul for IE\nif (!Math.imul) {\n    // tslint:disable-next-line:only-arrow-functions\n    Math.imul = function imul(a, b) {\n        var ah = (a >>> 16) & 0xffff;\n        var al = a & 0xffff;\n        var bh = (b >>> 16) & 0xffff;\n        var bl = b & 0xffff;\n        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5pdC50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmVyLy4vc3JjL2luaXQudHM/ZDE3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG52YXIgdztcbmlmICh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4gICAgdyA9IHtcbiAgICAgICAgY3J5cHRvOiB7XG4gICAgICAgICAgICBzdWJ0bGU6IHt9LFxuICAgICAgICAgICAgZ2V0UmFuZG9tVmFsdWVzOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gYXJyYXkuYnVmZmVyO1xuICAgICAgICAgICAgICAgIHZhciB1aW50OGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgICAgICAgICAgICAgdmFyIHJuZCA9IGNyeXB0b18xLnJhbmRvbUJ5dGVzKHVpbnQ4YnVmLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcm5kLmZvckVhY2goZnVuY3Rpb24gKG9jdGV0LCBpbmRleCkgeyByZXR1cm4gdWludDhidWZbaW5kZXhdID0gb2N0ZXQ7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIHcgPSBzZWxmO1xufVxuZXhwb3J0cy5uYXRpdmVDcnlwdG8gPSB3Lm1zQ3J5cHRvIHx8IHcuY3J5cHRvIHx8IHt9O1xuZXhwb3J0cy5uYXRpdmVTdWJ0bGUgPSBudWxsO1xudHJ5IHtcbiAgICBleHBvcnRzLm5hdGl2ZVN1YnRsZSA9IGV4cG9ydHMubmF0aXZlQ3J5cHRvLnN1YnRsZSB8fCBleHBvcnRzLm5hdGl2ZUNyeXB0by53ZWJraXRTdWJ0bGU7XG59XG5jYXRjaCAoZXJyKSB7XG4gICAgLy8gU2FmYXJpIHRocm93cyBlcnJvciBvbiBjcnlwdG8ud2Via2l0U3VidGxlIGluIFdvcmtlclxufVxuZnVuY3Rpb24gV3JhcEZ1bmN0aW9uKHN1YnRsZSwgbmFtZSkge1xuICAgIHZhciBmbiA9IHN1YnRsZVtuYW1lXTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25seS1hcnJvdy1mdW5jdGlvbnNcbiAgICBzdWJ0bGVbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIG9wID0gZm4uYXBwbHkoc3VidGxlLCBhcmdzKTtcbiAgICAgICAgICAgIG9wLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJFcnJvciBvbiBydW5uaW5nICdcIiArIG5hbWUgKyBcIicgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuaWYgKHcubXNDcnlwdG8pIHtcbiAgICBpZiAoIXcuUHJvbWlzZSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5NT0RVTEVfTk9UX0ZPVU5ELCBcIlByb21pc2VcIiwgXCJodHRwczovL3d3dy5wcm9taXNlanMub3JnXCIpO1xuICAgIH1cbiAgICBXcmFwRnVuY3Rpb24oZXhwb3J0cy5uYXRpdmVTdWJ0bGUsIFwiZ2VuZXJhdGVLZXlcIik7XG4gICAgV3JhcEZ1bmN0aW9uKGV4cG9ydHMubmF0aXZlU3VidGxlLCBcImRpZ2VzdFwiKTtcbiAgICBXcmFwRnVuY3Rpb24oZXhwb3J0cy5uYXRpdmVTdWJ0bGUsIFwic2lnblwiKTtcbiAgICBXcmFwRnVuY3Rpb24oZXhwb3J0cy5uYXRpdmVTdWJ0bGUsIFwidmVyaWZ5XCIpO1xuICAgIFdyYXBGdW5jdGlvbihleHBvcnRzLm5hdGl2ZVN1YnRsZSwgXCJlbmNyeXB0XCIpO1xuICAgIFdyYXBGdW5jdGlvbihleHBvcnRzLm5hdGl2ZVN1YnRsZSwgXCJkZWNyeXB0XCIpO1xuICAgIFdyYXBGdW5jdGlvbihleHBvcnRzLm5hdGl2ZVN1YnRsZSwgXCJpbXBvcnRLZXlcIik7XG4gICAgV3JhcEZ1bmN0aW9uKGV4cG9ydHMubmF0aXZlU3VidGxlLCBcImV4cG9ydEtleVwiKTtcbiAgICBXcmFwRnVuY3Rpb24oZXhwb3J0cy5uYXRpdmVTdWJ0bGUsIFwid3JhcEtleVwiKTtcbiAgICBXcmFwRnVuY3Rpb24oZXhwb3J0cy5uYXRpdmVTdWJ0bGUsIFwidW53cmFwS2V5XCIpO1xuICAgIFdyYXBGdW5jdGlvbihleHBvcnRzLm5hdGl2ZVN1YnRsZSwgXCJkZXJpdmVLZXlcIik7XG4gICAgV3JhcEZ1bmN0aW9uKGV4cG9ydHMubmF0aXZlU3VidGxlLCBcImRlcml2ZUJpdHNcIik7XG59XG4vLyBmaXg6IE1hdGguaW11bCBmb3IgSUVcbmlmICghTWF0aC5pbXVsKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9ubHktYXJyb3ctZnVuY3Rpb25zXG4gICAgTWF0aC5pbXVsID0gZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gICAgICAgIHZhciBhaCA9IChhID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIHZhciBhbCA9IGEgJiAweGZmZmY7XG4gICAgICAgIHZhciBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIHZhciBibCA9IGIgJiAweGZmZmY7XG4gICAgICAgIHJldHVybiAoKGFsICogYmwpICsgKCgoYWggKiBibCArIGFsICogYmgpIDw8IDE2KSA+Pj4gMCkgfCAwKTtcbiAgICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/init.ts\n");

/***/ }),

/***/ "./src/key.ts":
/*!********************!*\
  !*** ./src/key.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CryptoKey = /** @class */ (function () {\n    function CryptoKey(options) {\n        this.algorithm = options.algorithm;\n        if (options.type) {\n            this.type = options.type;\n        }\n        this.extractable = options.extractable;\n        this.usages = options.usages;\n    }\n    CryptoKey.prototype.copy = function (usages) {\n        var _a = this, algorithm = _a.algorithm, type = _a.type, extractable = _a.extractable;\n        var key = new CryptoKey({ algorithm: algorithm, type: type, extractable: extractable, usages: usages });\n        key.key = this.key;\n        return key;\n    };\n    return CryptoKey;\n}());\nexports.CryptoKey = CryptoKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMva2V5LnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvLi9zcmMva2V5LnRzP2I4N2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ3J5cHRvS2V5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENyeXB0b0tleShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4dHJhY3RhYmxlID0gb3B0aW9ucy5leHRyYWN0YWJsZTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBvcHRpb25zLnVzYWdlcztcbiAgICB9XG4gICAgQ3J5cHRvS2V5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHVzYWdlcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBhbGdvcml0aG0gPSBfYS5hbGdvcml0aG0sIHR5cGUgPSBfYS50eXBlLCBleHRyYWN0YWJsZSA9IF9hLmV4dHJhY3RhYmxlO1xuICAgICAgICB2YXIga2V5ID0gbmV3IENyeXB0b0tleSh7IGFsZ29yaXRobTogYWxnb3JpdGhtLCB0eXBlOiB0eXBlLCBleHRyYWN0YWJsZTogZXh0cmFjdGFibGUsIHVzYWdlczogdXNhZ2VzIH0pO1xuICAgICAgICBrZXkua2V5ID0gdGhpcy5rZXk7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgICByZXR1cm4gQ3J5cHRvS2V5O1xufSgpKTtcbmV4cG9ydHMuQ3J5cHRvS2V5ID0gQ3J5cHRvS2V5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/key.ts\n");

/***/ }),

/***/ "./src/lib.ts":
/*!********************!*\
  !*** ./src/lib.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar index_1 = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Object.freeze(Math);\n// Object.freeze(Math.random);\n// Object.freeze((Math as any).imul);\nif (index_1.nativeCrypto) {\n    Object.freeze(index_1.nativeCrypto.getRandomValues);\n}\nexports.crypto = new index_1.Crypto();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvLi9zcmMvbGliLnRzPzc1M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuLy8gT2JqZWN0LmZyZWV6ZShNYXRoKTtcbi8vIE9iamVjdC5mcmVlemUoTWF0aC5yYW5kb20pO1xuLy8gT2JqZWN0LmZyZWV6ZSgoTWF0aCBhcyBhbnkpLmltdWwpO1xuaWYgKGluZGV4XzEubmF0aXZlQ3J5cHRvKSB7XG4gICAgT2JqZWN0LmZyZWV6ZShpbmRleF8xLm5hdGl2ZUNyeXB0by5nZXRSYW5kb21WYWx1ZXMpO1xufVxuZXhwb3J0cy5jcnlwdG8gPSBuZXcgaW5kZXhfMS5DcnlwdG8oKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib.ts\n");

/***/ }),

/***/ "./src/rsa/crypto.ts":
/*!***************************!*\
  !*** ./src/rsa/crypto.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar webcrypto_core_1 = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\nvar error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nvar helper_1 = __webpack_require__(/*! ../helper */ \"./src/helper.ts\");\nvar key_1 = __webpack_require__(/*! ../key */ \"./src/key.ts\");\nvar crypto_1 = __webpack_require__(/*! ../crypto */ \"./src/crypto.ts\");\nfunction removeLeadingZero(buf) {\n    var first = true;\n    return buf.filter(function (v) {\n        if (first && v === 0) {\n            return false;\n        }\n        else {\n            first = false;\n            return true;\n        }\n    });\n}\nvar RsaCrypto = /** @class */ (function (_super) {\n    __extends(RsaCrypto, _super);\n    function RsaCrypto() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    RsaCrypto.generateKey = function (algorithm, extractable, keyUsage) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            _this.checkModule();\n            var pubExp = algorithm.publicExponent[0] === 3 ? 3 : 65537;\n            var rsaKey = asmCrypto.RSA.generateKey(algorithm.modulusLength, pubExp);\n            var privateKey = new key_1.CryptoKey({\n                type: \"private\",\n                algorithm: algorithm,\n                extractable: extractable,\n                usages: [],\n            });\n            var publicKey = new key_1.CryptoKey({\n                type: \"public\",\n                algorithm: algorithm,\n                extractable: true,\n                usages: [],\n            });\n            privateKey.key = publicKey.key = rsaKey;\n            switch (algorithm.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                    privateKey.usages = _this.filterUsages([\"decrypt\", \"unwrapKey\"], keyUsage);\n                    publicKey.usages = _this.filterUsages([\"encrypt\", \"wrapKey\"], keyUsage);\n                    break;\n                case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase():\n                    privateKey.usages = _this.filterUsages([\"sign\"], keyUsage);\n                    publicKey.usages = _this.filterUsages([\"verify\"], keyUsage);\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);\n            }\n            return { privateKey: privateKey, publicKey: publicKey };\n        });\n    };\n    RsaCrypto.sign = function (algorithm, key, data) {\n        return Promise.resolve()\n            .then(function () {\n            switch (algorithm.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase(): {\n                    var keyAlg = key.algorithm;\n                    var rsaAlg = algorithm;\n                    var sign = void 0;\n                    switch (keyAlg.hash.name.toUpperCase()) {\n                        case webcrypto_core_1.AlgorithmNames.Sha1:\n                            sign = asmCrypto.RSA_PKCS1_v1_5_SHA1.sign;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha256:\n                            sign = asmCrypto.RSA_PKCS1_v1_5_SHA256.sign;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha512:\n                            sign = asmCrypto.RSA_PKCS1_v1_5_SHA512.sign;\n                            break;\n                        default:\n                            throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, key.algorithm.name);\n                    }\n                    return sign(data, key.key).buffer;\n                }\n                case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase(): {\n                    var keyAlg = key.algorithm;\n                    var rsaAlg = algorithm;\n                    var sign = void 0;\n                    switch (keyAlg.hash.name.toUpperCase()) {\n                        case webcrypto_core_1.AlgorithmNames.Sha1:\n                            sign = asmCrypto.RSA_PSS_SHA1.sign;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha256:\n                            sign = asmCrypto.RSA_PSS_SHA256.sign;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha512:\n                            sign = asmCrypto.RSA_PSS_SHA512.sign;\n                            break;\n                        default:\n                            throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, key.algorithm.name);\n                    }\n                    return sign(data, key.key, rsaAlg.saltLength).buffer;\n                }\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);\n            }\n        });\n    };\n    RsaCrypto.verify = function (algorithm, key, signature, data) {\n        return Promise.resolve()\n            .then(function () {\n            switch (algorithm.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase(): {\n                    var keyAlg_1 = key.algorithm;\n                    var rsaAlg_1 = algorithm;\n                    var verify_1;\n                    switch (keyAlg_1.hash.name.toUpperCase()) {\n                        case webcrypto_core_1.AlgorithmNames.Sha1:\n                            verify_1 = asmCrypto.RSA_PKCS1_v1_5_SHA1.verify;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha256:\n                            verify_1 = asmCrypto.RSA_PKCS1_v1_5_SHA256.verify;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha512:\n                            verify_1 = asmCrypto.RSA_PKCS1_v1_5_SHA512.verify;\n                            break;\n                        default:\n                            throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, key.algorithm.name);\n                    }\n                    try {\n                        return verify_1(signature, data, key.key);\n                    }\n                    catch (err) {\n                        console.warn(\"Verify error: \" + err.message);\n                        return false;\n                    }\n                }\n                case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase():\n                    var keyAlg = key.algorithm;\n                    var rsaAlg = algorithm;\n                    var verify = void 0;\n                    switch (keyAlg.hash.name.toUpperCase()) {\n                        case webcrypto_core_1.AlgorithmNames.Sha1:\n                            verify = asmCrypto.RSA_PSS_SHA1.verify;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha256:\n                            verify = asmCrypto.RSA_PSS_SHA256.verify;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha512:\n                            verify = asmCrypto.RSA_PSS_SHA512.verify;\n                            break;\n                        default:\n                            throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, key.algorithm.name);\n                    }\n                    try {\n                        return verify(signature, data, key.key, rsaAlg.saltLength);\n                    }\n                    catch (err) {\n                        console.warn(\"Verify error: \" + err.message);\n                        return false;\n                    }\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);\n            }\n        });\n    };\n    RsaCrypto.encrypt = function (algorithm, key, data) {\n        return Promise.resolve()\n            .then(function () {\n            switch (algorithm.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                    var keyAlg = key.algorithm;\n                    var rsaAlg = algorithm;\n                    var encrypt = void 0;\n                    switch (keyAlg.hash.name.toUpperCase()) {\n                        case webcrypto_core_1.AlgorithmNames.Sha1:\n                            encrypt = asmCrypto.RSA_OAEP_SHA1.encrypt;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha256:\n                            encrypt = asmCrypto.RSA_OAEP_SHA256.encrypt;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha512:\n                            encrypt = asmCrypto.RSA_OAEP_SHA512.encrypt;\n                            break;\n                        default:\n                            throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, keyAlg.name + \" \" + keyAlg.hash.name);\n                    }\n                    var label = void 0;\n                    if (rsaAlg.label) {\n                        label = webcrypto_core_1.PrepareData(rsaAlg.label, \"label\");\n                    }\n                    return encrypt(data, key.key, label);\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);\n            }\n        });\n    };\n    RsaCrypto.decrypt = function (algorithm, key, data) {\n        return Promise.resolve()\n            .then(function () {\n            switch (algorithm.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                    var keyAlg = key.algorithm;\n                    var rsaAlg = algorithm;\n                    var decrypt = void 0;\n                    switch (keyAlg.hash.name.toUpperCase()) {\n                        case webcrypto_core_1.AlgorithmNames.Sha1:\n                            decrypt = asmCrypto.RSA_OAEP_SHA1.decrypt;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha256:\n                            decrypt = asmCrypto.RSA_OAEP_SHA256.decrypt;\n                            break;\n                        case webcrypto_core_1.AlgorithmNames.Sha512:\n                            decrypt = asmCrypto.RSA_OAEP_SHA512.decrypt;\n                            break;\n                        default:\n                            throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, keyAlg.name + \" \" + keyAlg.hash.name);\n                    }\n                    var label = void 0;\n                    if (rsaAlg.label) {\n                        label = webcrypto_core_1.PrepareData(rsaAlg.label, \"label\");\n                    }\n                    return decrypt(data, key.key, label);\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, algorithm.name);\n            }\n        });\n    };\n    RsaCrypto.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {\n        var crypto;\n        return Promise.resolve()\n            .then(function () {\n            crypto = new crypto_1.Crypto();\n            return crypto.subtle.exportKey(format, key);\n        })\n            .then(function (data) {\n            var raw;\n            if (!(data instanceof ArrayBuffer)) {\n                // JWK\n                raw = helper_1.string2buffer(JSON.stringify(data));\n            }\n            else {\n                // ArrayBuffer\n                raw = new Uint8Array(data);\n            }\n            var copyKey = wrappingKey.copy([\"encrypt\"]);\n            return crypto.subtle.encrypt(wrapAlgorithm, copyKey, raw);\n        });\n    };\n    RsaCrypto.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\n        var crypto;\n        return Promise.resolve()\n            .then(function () {\n            crypto = new crypto_1.Crypto();\n            var copyKey = unwrappingKey.copy([\"decrypt\"]);\n            return crypto.subtle.decrypt(unwrapAlgorithm, copyKey, wrappedKey);\n        })\n            .then(function (data) {\n            var preparedData;\n            if (format.toLowerCase() === \"jwk\") {\n                preparedData = JSON.parse(helper_1.buffer2string(new Uint8Array(data)));\n            }\n            else {\n                preparedData = new Uint8Array(data);\n            }\n            return crypto.subtle.importKey(format, preparedData, unwrappedKeyAlgorithm, extractable, keyUsages);\n        });\n    };\n    RsaCrypto.alg2jwk = function (alg) {\n        var hash = alg.hash;\n        var hashSize = /(\\d+)/.exec(hash.name)[1];\n        switch (alg.name.toUpperCase()) {\n            case webcrypto_core_1.AlgorithmNames.RsaOAEP.toUpperCase():\n                return \"RSA-OAEP\" + (hashSize === \"1\" ? \"\" : \"-\" + hashSize);\n            case webcrypto_core_1.AlgorithmNames.RsaPSS.toUpperCase():\n                return \"PS\" + hashSize;\n            case webcrypto_core_1.AlgorithmNames.RsaSSA.toUpperCase():\n                return \"RS\" + hashSize;\n            default:\n                throw new webcrypto_core_1.AlgorithmError(webcrypto_core_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);\n        }\n    };\n    RsaCrypto.jwk2alg = function (alg) {\n        throw new Error(\"Not implemented\");\n    };\n    RsaCrypto.exportKey = function (format, key) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            if (format.toLowerCase() === \"jwk\") {\n                var jwk = {\n                    kty: \"RSA\",\n                    ext: true,\n                    key_ops: key.usages,\n                };\n                jwk.alg = _this.alg2jwk(key.algorithm);\n                jwk.n = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[0]));\n                jwk.e = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[1]));\n                if (key.type === \"private\") {\n                    jwk.d = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[2]));\n                    jwk.p = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[3]));\n                    jwk.q = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[4]));\n                    jwk.dp = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[5]));\n                    jwk.dq = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[6]));\n                    jwk.qi = webcrypto_core_1.Base64Url.encode(removeLeadingZero(key.key[7]));\n                }\n                return jwk;\n            }\n            else {\n                throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED);\n            }\n        });\n    };\n    RsaCrypto.importKey = function (format, keyData, algorithm, extractable, usages) {\n        return Promise.resolve()\n            .then(function () {\n            var jwk;\n            var key = new key_1.CryptoKey({\n                algorithm: algorithm,\n                extractable: extractable,\n                usages: usages,\n            });\n            key.key = [];\n            if (format.toLowerCase() === \"jwk\") {\n                jwk = keyData;\n                key.key[0] = webcrypto_core_1.Base64Url.decode(jwk.n);\n                key.key[1] = webcrypto_core_1.Base64Url.decode(jwk.e)[0] === 3 ? new Uint8Array([0, 0, 0, 3]) : new Uint8Array([0, 1, 0, 1]);\n                if (jwk.d) {\n                    key.type = \"private\";\n                    key.key[2] = webcrypto_core_1.Base64Url.decode(jwk.d);\n                    key.key[3] = webcrypto_core_1.Base64Url.decode(jwk.p);\n                    key.key[4] = webcrypto_core_1.Base64Url.decode(jwk.q);\n                    key.key[5] = webcrypto_core_1.Base64Url.decode(jwk.dp);\n                    key.key[6] = webcrypto_core_1.Base64Url.decode(jwk.dq);\n                    key.key[7] = webcrypto_core_1.Base64Url.decode(jwk.qi);\n                }\n                else {\n                    key.type = \"public\";\n                }\n                return key;\n            }\n            else {\n                throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED);\n            }\n        });\n    };\n    RsaCrypto.checkModule = function () {\n        if (typeof asmCrypto === \"undefined\") {\n            throw new error_1.LinerError(error_1.LinerError.MODULE_NOT_FOUND, \"asmCrypto\", \"https://github.com/vibornoff/asmcrypto.js\");\n        }\n    };\n    RsaCrypto.filterUsages = function (supported, given) {\n        return supported.filter(function (item1) { return !!given.filter(function (item2) { return item1 === item2; }).length; });\n    };\n    return RsaCrypto;\n}(webcrypto_core_1.BaseCrypto));\nexports.RsaCrypto = RsaCrypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcnNhL2NyeXB0by50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmVyLy4vc3JjL3JzYS9jcnlwdG8udHM/N2U1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdlYmNyeXB0b19jb3JlXzEgPSByZXF1aXJlKFwid2ViY3J5cHRvLWNvcmVcIik7XG52YXIgZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcbnZhciBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJcIik7XG52YXIga2V5XzEgPSByZXF1aXJlKFwiLi4va2V5XCIpO1xudmFyIGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0b1wiKTtcbmZ1bmN0aW9uIHJlbW92ZUxlYWRpbmdaZXJvKGJ1Zikge1xuICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgcmV0dXJuIGJ1Zi5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKGZpcnN0ICYmIHYgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxudmFyIFJzYUNyeXB0byA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUnNhQ3J5cHRvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJzYUNyeXB0bygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSc2FDcnlwdG8uZ2VuZXJhdGVLZXkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGVja01vZHVsZSgpO1xuICAgICAgICAgICAgdmFyIHB1YkV4cCA9IGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudFswXSA9PT0gMyA/IDMgOiA2NTUzNztcbiAgICAgICAgICAgIHZhciByc2FLZXkgPSBhc21DcnlwdG8uUlNBLmdlbmVyYXRlS2V5KGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoLCBwdWJFeHApO1xuICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBuZXcga2V5XzEuQ3J5cHRvS2V5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IGFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICBleHRyYWN0YWJsZTogZXh0cmFjdGFibGUsXG4gICAgICAgICAgICAgICAgdXNhZ2VzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHB1YmxpY0tleSA9IG5ldyBrZXlfMS5DcnlwdG9LZXkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicHVibGljXCIsXG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgZXh0cmFjdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdXNhZ2VzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJpdmF0ZUtleS5rZXkgPSBwdWJsaWNLZXkua2V5ID0gcnNhS2V5O1xuICAgICAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYU9BRVAudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBfdGhpcy5maWx0ZXJVc2FnZXMoW1wiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXSwga2V5VXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0gX3RoaXMuZmlsdGVyVXNhZ2VzKFtcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdLCBrZXlVc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FTU0EudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhUFNTLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0gX3RoaXMuZmlsdGVyVXNhZ2VzKFtcInNpZ25cIl0sIGtleVVzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5LnVzYWdlcyA9IF90aGlzLmZpbHRlclVzYWdlcyhbXCJ2ZXJpZnlcIl0sIGtleVVzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGdvcml0aG0ubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBwcml2YXRlS2V5OiBwcml2YXRlS2V5LCBwdWJsaWNLZXk6IHB1YmxpY0tleSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJzYUNyeXB0by5zaWduID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYVNTQS50b0xvd2VyQ2FzZSgpOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlBbGcgPSBrZXkuYWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnNhQWxnID0gYWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrZXlBbGcuaGFzaC5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5TaGExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSBhc21DcnlwdG8uUlNBX1BLQ1MxX3YxXzVfU0hBMS5zaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTI1NjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gYXNtQ3J5cHRvLlJTQV9QS0NTMV92MV81X1NIQTI1Ni5zaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTUxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gYXNtQ3J5cHRvLlJTQV9QS0NTMV92MV81X1NIQTUxMi5zaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGtleS5hbGdvcml0aG0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24oZGF0YSwga2V5LmtleSkuYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhUFNTLnRvTG93ZXJDYXNlKCk6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUFsZyA9IGtleS5hbGdvcml0aG07XG4gICAgICAgICAgICAgICAgICAgIHZhciByc2FBbGcgPSBhbGdvcml0aG07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleUFsZy5oYXNoLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IGFzbUNyeXB0by5SU0FfUFNTX1NIQTEuc2lnbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5TaGEyNTY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IGFzbUNyeXB0by5SU0FfUFNTX1NIQTI1Ni5zaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTUxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gYXNtQ3J5cHRvLlJTQV9QU1NfU0hBNTEyLnNpZ247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwga2V5LmFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbihkYXRhLCBrZXkua2V5LCByc2FBbGcuc2FsdExlbmd0aCkuYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSc2FDcnlwdG8udmVyaWZ5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhU1NBLnRvTG93ZXJDYXNlKCk6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUFsZ18xID0ga2V5LmFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJzYUFsZ18xID0gYWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyaWZ5XzE7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5QWxnXzEuaGFzaC5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5TaGExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeV8xID0gYXNtQ3J5cHRvLlJTQV9QS0NTMV92MV81X1NIQTEudmVyaWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTI1NjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnlfMSA9IGFzbUNyeXB0by5SU0FfUEtDUzFfdjFfNV9TSEEyNTYudmVyaWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTUxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnlfMSA9IGFzbUNyeXB0by5SU0FfUEtDUzFfdjFfNV9TSEE1MTIudmVyaWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGtleS5hbGdvcml0aG0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJpZnlfMShzaWduYXR1cmUsIGRhdGEsIGtleS5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZlcmlmeSBlcnJvcjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYVBTUy50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5QWxnID0ga2V5LmFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJzYUFsZyA9IGFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcmlmeSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrZXlBbGcuaGFzaC5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5TaGExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeSA9IGFzbUNyeXB0by5SU0FfUFNTX1NIQTEudmVyaWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTI1NjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnkgPSBhc21DcnlwdG8uUlNBX1BTU19TSEEyNTYudmVyaWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTUxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnkgPSBhc21DcnlwdG8uUlNBX1BTU19TSEE1MTIudmVyaWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGtleS5hbGdvcml0aG0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJpZnkoc2lnbmF0dXJlLCBkYXRhLCBrZXkua2V5LCByc2FBbGcuc2FsdExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmVyaWZ5IGVycm9yOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwgYWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJzYUNyeXB0by5lbmNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYU9BRVAudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUFsZyA9IGtleS5hbGdvcml0aG07XG4gICAgICAgICAgICAgICAgICAgIHZhciByc2FBbGcgPSBhbGdvcml0aG07XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmNyeXB0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleUFsZy5oYXNoLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdCA9IGFzbUNyeXB0by5SU0FfT0FFUF9TSEExLmVuY3J5cHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuU2hhMjU2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQgPSBhc21DcnlwdG8uUlNBX09BRVBfU0hBMjU2LmVuY3J5cHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuU2hhNTEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQgPSBhc21DcnlwdG8uUlNBX09BRVBfU0hBNTEyLmVuY3J5cHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwga2V5QWxnLm5hbWUgKyBcIiBcIiArIGtleUFsZy5oYXNoLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJzYUFsZy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSB3ZWJjcnlwdG9fY29yZV8xLlByZXBhcmVEYXRhKHJzYUFsZy5sYWJlbCwgXCJsYWJlbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdChkYXRhLCBrZXkua2V5LCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGdvcml0aG0ubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUnNhQ3J5cHRvLmRlY3J5cHQgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhT0FFUC50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5QWxnID0ga2V5LmFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJzYUFsZyA9IGFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3J5cHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5QWxnLmhhc2gubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuU2hhMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ID0gYXNtQ3J5cHRvLlJTQV9PQUVQX1NIQTEuZGVjcnlwdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5TaGEyNTY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcnlwdCA9IGFzbUNyeXB0by5SU0FfT0FFUF9TSEEyNTYuZGVjcnlwdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5TaGE1MTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcnlwdCA9IGFzbUNyeXB0by5SU0FfT0FFUF9TSEE1MTIuZGVjcnlwdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBrZXlBbGcubmFtZSArIFwiIFwiICsga2V5QWxnLmhhc2gubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnNhQWxnLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHdlYmNyeXB0b19jb3JlXzEuUHJlcGFyZURhdGEocnNhQWxnLmxhYmVsLCBcImxhYmVsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNyeXB0KGRhdGEsIGtleS5rZXksIGxhYmVsKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSc2FDcnlwdG8ud3JhcEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleSwgd3JhcHBpbmdLZXksIHdyYXBBbGdvcml0aG0pIHtcbiAgICAgICAgdmFyIGNyeXB0bztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcnlwdG8gPSBuZXcgY3J5cHRvXzEuQ3J5cHRvKCk7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoZm9ybWF0LCBrZXkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciByYXc7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSldLXG4gICAgICAgICAgICAgICAgcmF3ID0gaGVscGVyXzEuc3RyaW5nMmJ1ZmZlcihKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgIHJhdyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvcHlLZXkgPSB3cmFwcGluZ0tleS5jb3B5KFtcImVuY3J5cHRcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZW5jcnlwdCh3cmFwQWxnb3JpdGhtLCBjb3B5S2V5LCByYXcpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJzYUNyeXB0by51bndyYXBLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCB3cmFwcGVkS2V5LCB1bndyYXBwaW5nS2V5LCB1bndyYXBBbGdvcml0aG0sIHVud3JhcHBlZEtleUFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICB2YXIgY3J5cHRvO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyeXB0byA9IG5ldyBjcnlwdG9fMS5DcnlwdG8oKTtcbiAgICAgICAgICAgIHZhciBjb3B5S2V5ID0gdW53cmFwcGluZ0tleS5jb3B5KFtcImRlY3J5cHRcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGVjcnlwdCh1bndyYXBBbGdvcml0aG0sIGNvcHlLZXksIHdyYXBwZWRLZXkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBwcmVwYXJlZERhdGE7XG4gICAgICAgICAgICBpZiAoZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgICAgICBwcmVwYXJlZERhdGEgPSBKU09OLnBhcnNlKGhlbHBlcl8xLmJ1ZmZlcjJzdHJpbmcobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXBhcmVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KGZvcm1hdCwgcHJlcGFyZWREYXRhLCB1bndyYXBwZWRLZXlBbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJzYUNyeXB0by5hbGcyandrID0gZnVuY3Rpb24gKGFsZykge1xuICAgICAgICB2YXIgaGFzaCA9IGFsZy5oYXNoO1xuICAgICAgICB2YXIgaGFzaFNpemUgPSAvKFxcZCspLy5leGVjKGhhc2gubmFtZSlbMV07XG4gICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYU9BRVAudG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtT0FFUFwiICsgKGhhc2hTaXplID09PSBcIjFcIiA/IFwiXCIgOiBcIi1cIiArIGhhc2hTaXplKTtcbiAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FQU1MudG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJQU1wiICsgaGFzaFNpemU7XG4gICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhU1NBLnRvVXBwZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNcIiArIGhhc2hTaXplO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1FcnJvcih3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobUVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwgYWxnLm5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSc2FDcnlwdG8uandrMmFsZyA9IGZ1bmN0aW9uIChhbGcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG4gICAgUnNhQ3J5cHRvLmV4cG9ydEtleSA9IGZ1bmN0aW9uIChmb3JtYXQsIGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgICAgIHZhciBqd2sgPSB7XG4gICAgICAgICAgICAgICAgICAgIGt0eTogXCJSU0FcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBrZXlfb3BzOiBrZXkudXNhZ2VzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgandrLmFsZyA9IF90aGlzLmFsZzJqd2soa2V5LmFsZ29yaXRobSk7XG4gICAgICAgICAgICAgICAgandrLm4gPSB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5lbmNvZGUocmVtb3ZlTGVhZGluZ1plcm8oa2V5LmtleVswXSkpO1xuICAgICAgICAgICAgICAgIGp3ay5lID0gd2ViY3J5cHRvX2NvcmVfMS5CYXNlNjRVcmwuZW5jb2RlKHJlbW92ZUxlYWRpbmdaZXJvKGtleS5rZXlbMV0pKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGp3ay5kID0gd2ViY3J5cHRvX2NvcmVfMS5CYXNlNjRVcmwuZW5jb2RlKHJlbW92ZUxlYWRpbmdaZXJvKGtleS5rZXlbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgandrLnAgPSB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5lbmNvZGUocmVtb3ZlTGVhZGluZ1plcm8oa2V5LmtleVszXSkpO1xuICAgICAgICAgICAgICAgICAgICBqd2sucSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmVuY29kZShyZW1vdmVMZWFkaW5nWmVybyhrZXkua2V5WzRdKSk7XG4gICAgICAgICAgICAgICAgICAgIGp3ay5kcCA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmVuY29kZShyZW1vdmVMZWFkaW5nWmVybyhrZXkua2V5WzVdKSk7XG4gICAgICAgICAgICAgICAgICAgIGp3ay5kcSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmVuY29kZShyZW1vdmVMZWFkaW5nWmVybyhrZXkua2V5WzZdKSk7XG4gICAgICAgICAgICAgICAgICAgIGp3ay5xaSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmVuY29kZShyZW1vdmVMZWFkaW5nWmVybyhrZXkua2V5WzddKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5OT1RfU1VQUE9SVEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSc2FDcnlwdG8uaW1wb3J0S2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwgdXNhZ2VzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGp3aztcbiAgICAgICAgICAgIHZhciBrZXkgPSBuZXcga2V5XzEuQ3J5cHRvS2V5KHtcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IGFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICBleHRyYWN0YWJsZTogZXh0cmFjdGFibGUsXG4gICAgICAgICAgICAgICAgdXNhZ2VzOiB1c2FnZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGtleS5rZXkgPSBbXTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgICAgIGp3ayA9IGtleURhdGE7XG4gICAgICAgICAgICAgICAga2V5LmtleVswXSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmRlY29kZShqd2subik7XG4gICAgICAgICAgICAgICAga2V5LmtleVsxXSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmRlY29kZShqd2suZSlbMF0gPT09IDMgPyBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgM10pIDogbmV3IFVpbnQ4QXJyYXkoWzAsIDEsIDAsIDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LnR5cGUgPSBcInByaXZhdGVcIjtcbiAgICAgICAgICAgICAgICAgICAga2V5LmtleVsyXSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmRlY29kZShqd2suZCk7XG4gICAgICAgICAgICAgICAgICAgIGtleS5rZXlbM10gPSB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5kZWNvZGUoandrLnApO1xuICAgICAgICAgICAgICAgICAgICBrZXkua2V5WzRdID0gd2ViY3J5cHRvX2NvcmVfMS5CYXNlNjRVcmwuZGVjb2RlKGp3ay5xKTtcbiAgICAgICAgICAgICAgICAgICAga2V5LmtleVs1XSA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmRlY29kZShqd2suZHApO1xuICAgICAgICAgICAgICAgICAgICBrZXkua2V5WzZdID0gd2ViY3J5cHRvX2NvcmVfMS5CYXNlNjRVcmwuZGVjb2RlKGp3ay5kcSk7XG4gICAgICAgICAgICAgICAgICAgIGtleS5rZXlbN10gPSB3ZWJjcnlwdG9fY29yZV8xLkJhc2U2NFVybC5kZWNvZGUoandrLnFpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleS50eXBlID0gXCJwdWJsaWNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLk5PVF9TVVBQT1JURUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJzYUNyeXB0by5jaGVja01vZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhc21DcnlwdG8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLk1PRFVMRV9OT1RfRk9VTkQsIFwiYXNtQ3J5cHRvXCIsIFwiaHR0cHM6Ly9naXRodWIuY29tL3ZpYm9ybm9mZi9hc21jcnlwdG8uanNcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJzYUNyeXB0by5maWx0ZXJVc2FnZXMgPSBmdW5jdGlvbiAoc3VwcG9ydGVkLCBnaXZlbikge1xuICAgICAgICByZXR1cm4gc3VwcG9ydGVkLmZpbHRlcihmdW5jdGlvbiAoaXRlbTEpIHsgcmV0dXJuICEhZ2l2ZW4uZmlsdGVyKGZ1bmN0aW9uIChpdGVtMikgeyByZXR1cm4gaXRlbTEgPT09IGl0ZW0yOyB9KS5sZW5ndGg7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJzYUNyeXB0bztcbn0od2ViY3J5cHRvX2NvcmVfMS5CYXNlQ3J5cHRvKSk7XG5leHBvcnRzLlJzYUNyeXB0byA9IFJzYUNyeXB0bztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/rsa/crypto.ts\n");

/***/ }),

/***/ "./src/sha/crypto.ts":
/*!***************************!*\
  !*** ./src/sha/crypto.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar webcrypto_core_1 = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\nvar error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nvar ShaCrypto = /** @class */ (function (_super) {\n    __extends(ShaCrypto, _super);\n    function ShaCrypto() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ShaCrypto.digest = function (alg, message) {\n        return Promise.resolve()\n            .then(function () {\n            if (typeof asmCrypto === \"undefined\") {\n                throw new error_1.LinerError(error_1.LinerError.MODULE_NOT_FOUND, \"asmCrypto\", \"https://github.com/vibornoff/asmcrypto.js\");\n            }\n            switch (alg.name.toUpperCase()) {\n                case webcrypto_core_1.AlgorithmNames.Sha1:\n                    return asmCrypto.SHA1.bytes(message).buffer;\n                case webcrypto_core_1.AlgorithmNames.Sha256:\n                    return asmCrypto.SHA256.bytes(message).buffer;\n                case webcrypto_core_1.AlgorithmNames.Sha512:\n                    return asmCrypto.SHA512.bytes(message).buffer;\n                default:\n                    throw new error_1.LinerError(\"Not supported algorithm '\" + alg.name + \"'\");\n            }\n        });\n    };\n    return ShaCrypto;\n}(webcrypto_core_1.BaseCrypto));\nexports.ShaCrypto = ShaCrypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhL2NyeXB0by50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmVyLy4vc3JjL3NoYS9jcnlwdG8udHM/NzgwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdlYmNyeXB0b19jb3JlXzEgPSByZXF1aXJlKFwid2ViY3J5cHRvLWNvcmVcIik7XG52YXIgZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcbnZhciBTaGFDcnlwdG8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNoYUNyeXB0bywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaGFDcnlwdG8oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU2hhQ3J5cHRvLmRpZ2VzdCA9IGZ1bmN0aW9uIChhbGcsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFzbUNyeXB0byA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLk1PRFVMRV9OT1RfRk9VTkQsIFwiYXNtQ3J5cHRvXCIsIFwiaHR0cHM6Ly9naXRodWIuY29tL3ZpYm9ybm9mZi9hc21jcnlwdG8uanNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuU2hhMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzbUNyeXB0by5TSEExLmJ5dGVzKG1lc3NhZ2UpLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuU2hhMjU2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNtQ3J5cHRvLlNIQTI1Ni5ieXRlcyhtZXNzYWdlKS5idWZmZXI7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlNoYTUxMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzbUNyeXB0by5TSEE1MTIuYnl0ZXMobWVzc2FnZSkuYnVmZmVyO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIGFsZ29yaXRobSAnXCIgKyBhbGcubmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2hhQ3J5cHRvO1xufSh3ZWJjcnlwdG9fY29yZV8xLkJhc2VDcnlwdG8pKTtcbmV4cG9ydHMuU2hhQ3J5cHRvID0gU2hhQ3J5cHRvO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/sha/crypto.ts\n");

/***/ }),

/***/ "./src/subtle.ts":
/*!***********************!*\
  !*** ./src/subtle.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Core\nvar webcrypto_core_1 = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\nvar core = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\nvar webcrypto_core_2 = __webpack_require__(/*! webcrypto-core */ \"./node_modules/webcrypto-core/dist/webcrypto-core.es.js\");\n// Base\nvar init_1 = __webpack_require__(/*! ./init */ \"./src/init.ts\");\nvar crypto_1 = __webpack_require__(/*! ./crypto */ \"./src/crypto.ts\");\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/error.ts\");\nvar helper_1 = __webpack_require__(/*! ./helper */ \"./src/helper.ts\");\n// Crypto\nvar crypto_2 = __webpack_require__(/*! ./aes/crypto */ \"./src/aes/crypto.ts\");\nvar crypto_3 = __webpack_require__(/*! ./sha/crypto */ \"./src/sha/crypto.ts\");\nvar crypto_4 = __webpack_require__(/*! ./rsa/crypto */ \"./src/rsa/crypto.ts\");\nvar crypto_5 = __webpack_require__(/*! ./ec/crypto */ \"./src/ec/crypto.ts\");\nvar keys = [];\nfunction PrepareKey(key, subtle) {\n    return Promise.resolve()\n        .then(function () {\n        if (key.key) {\n            return key;\n        }\n        if (!key.extractable) {\n            throw new error_1.LinerError(\"'key' is Native CryptoKey. It can't be converted to JS CryptoKey\");\n        }\n        else {\n            var crypto_6 = new crypto_1.Crypto();\n            return crypto_6.subtle.exportKey(\"jwk\", key)\n                .then(function (jwk) {\n                var alg = GetHashAlgorithm(key);\n                if (alg) {\n                    alg = helper_1.assign(alg, key.algorithm);\n                }\n                return subtle.importKey(\"jwk\", jwk, alg, true, key.usages);\n            });\n        }\n    });\n}\nvar SubtleCrypto = /** @class */ (function (_super) {\n    __extends(SubtleCrypto, _super);\n    function SubtleCrypto() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SubtleCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\n        var _this = this;\n        var args = arguments;\n        var alg;\n        return _super.prototype.generateKey.apply(this, args)\n            .then(function (d) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            var browser = helper_1.BrowserInfo();\n            if ((browser.name === helper_1.Browser.Edge && alg.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.AesGCM) ||\n                // Don't do AES-GCM key generation, because Edge throws errors on GCM encrypt, decrypt, wrapKey, unwrapKey\n                CheckAppleRsaOAEP(alg.name)\n            // Don't use native generateKey for RSA-OAEP on Safari before v11\n            // https://github.com/PeculiarVentures/webcrypto-liner/issues/53\n            ) {\n                return;\n            }\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.generateKey.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native generateKey for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    helper_1.warn(\"WebCrypto: native generateKey for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (generatedKeys) {\n            if (generatedKeys) {\n                var promise = Promise.resolve(generatedKeys);\n                /**\n                 * Safari issue\n                 * https://github.com/PeculiarVentures/webcrypto-liner/issues/39\n                 * if public key cannot be exported in correct JWK format, then run new generateKey\n                 */\n                if (helper_1.BrowserInfo().name === helper_1.Browser.Safari &&\n                    (alg.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.EcDH.toUpperCase() ||\n                        alg.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.EcDSA.toUpperCase())) {\n                    var pubKey_1 = generatedKeys.publicKey;\n                    promise = promise.then(function () {\n                        return _this.exportKey(\"jwk\", pubKey_1)\n                            .then(function (jwk) {\n                            return _this.exportKey(\"spki\", pubKey_1)\n                                .then(function (spki) {\n                                var x = webcrypto_core_1.Base64Url.decode(jwk.x);\n                                var y = webcrypto_core_1.Base64Url.decode(jwk.y);\n                                var len = x.length + y.length;\n                                var spkiBuf = new Uint8Array(spki);\n                                for (var i = 0; i < len; i++) {\n                                    var spkiByte = spkiBuf[spkiBuf.length - i - 1];\n                                    var pointByte = void 0;\n                                    if (i < y.length) {\n                                        pointByte = y[y.length - i - 1];\n                                    }\n                                    else {\n                                        pointByte = x[x.length + y.length - i - 1];\n                                    }\n                                    if (spkiByte !== pointByte) {\n                                        // regenerate new key\n                                        helper_1.warn(\"WebCrypto: EC key has wrong public key JWK. Key pair will be recreated\");\n                                        return _this.generateKey(algorithm, extractable, keyUsages);\n                                    }\n                                }\n                                return generatedKeys;\n                            });\n                        });\n                    });\n                }\n                return promise.then(function (keys2) {\n                    FixCryptoKeyUsages(keys2, keyUsages);\n                    SetHashAlgorithm(alg, keys2);\n                    return keys2;\n                });\n            }\n            var Class;\n            switch (alg.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.AesECB.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():\n                    Class = crypto_2.AesCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.EcDSA.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.EcDH.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase():\n                    Class = crypto_4.RsaCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, alg.name.toLowerCase());\n            }\n            return Class.generateKey(alg, extractable, keyUsages);\n        });\n    };\n    SubtleCrypto.prototype.digest = function (algorithm, data) {\n        var args = arguments;\n        var alg;\n        var dataBytes;\n        return _super.prototype.digest.apply(this, args)\n            .then(function (d) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            dataBytes = webcrypto_core_2.PrepareData(data, \"data\");\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.digest.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native digest for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    helper_1.warn(\"WebCrypto: native digest for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (digest) {\n            if (digest) {\n                return digest;\n            }\n            return crypto_3.ShaCrypto.digest(alg, dataBytes);\n        });\n    };\n    SubtleCrypto.prototype.sign = function (algorithm, key, data) {\n        var args = arguments;\n        var alg;\n        var dataBytes;\n        return _super.prototype.sign.apply(this, args)\n            .then(function (d) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            dataBytes = webcrypto_core_2.PrepareData(data, \"data\");\n            var alg2 = GetHashAlgorithm(key);\n            if (alg2) {\n                args[0] = helper_1.assign(alg, alg2);\n            }\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.sign.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native sign for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    helper_1.warn(\"WebCrypto: native sign for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (signature) {\n            if (signature) {\n                return signature;\n            }\n            var Class;\n            switch (alg.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.EcDSA.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.EdDSA.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase():\n                    Class = crypto_4.RsaCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, alg.name.toLowerCase());\n            }\n            return PrepareKey(key, Class)\n                .then(function (preparedKey) { return Class.sign(alg, preparedKey, dataBytes); });\n        });\n    };\n    SubtleCrypto.prototype.verify = function (algorithm, key, signature, data) {\n        var args = arguments;\n        var alg;\n        var signatureBytes;\n        var dataBytes;\n        return _super.prototype.verify.apply(this, args)\n            .then(function (d) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            signatureBytes = webcrypto_core_2.PrepareData(signature, \"data\");\n            dataBytes = webcrypto_core_2.PrepareData(data, \"data\");\n            var alg2 = GetHashAlgorithm(key);\n            if (alg2) {\n                args[0] = helper_1.assign(alg, alg2);\n            }\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.verify.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native verify for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    helper_1.warn(\"WebCrypto: native verify for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (result) {\n            if (typeof result === \"boolean\") {\n                return result;\n            }\n            var Class;\n            switch (alg.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.EcDSA.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.EdDSA.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase():\n                    Class = crypto_4.RsaCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, alg.name.toLowerCase());\n            }\n            return PrepareKey(key, Class)\n                .then(function (preparedKey) { return Class.verify(alg, preparedKey, signatureBytes, dataBytes); });\n        });\n    };\n    SubtleCrypto.prototype.deriveBits = function (algorithm, baseKey, length) {\n        var args = arguments;\n        var alg;\n        return _super.prototype.deriveBits.apply(this, args)\n            .then(function (bits) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.deriveBits.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native deriveBits for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    // Edge throws error. Don't know Why.\n                    helper_1.warn(\"WebCrypto: native deriveBits for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (bits) {\n            if (bits) {\n                return bits;\n            }\n            var Class;\n            switch (alg.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.EcDH.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED, \"deriveBits\");\n            }\n            return Class.deriveBits(alg, baseKey, length);\n        });\n    };\n    SubtleCrypto.prototype.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\n        var args = arguments;\n        var alg;\n        var algDerivedKey;\n        return _super.prototype.deriveKey.apply(this, args)\n            .then(function (bits) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            algDerivedKey = webcrypto_core_2.PrepareAlgorithm(derivedKeyType);\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.deriveKey.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native deriveKey for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    // Edge doesn't go to catch of Promise\n                    helper_1.warn(\"WebCrypto: native deriveKey for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (key) {\n            if (key) {\n                FixCryptoKeyUsages(key, keyUsages);\n                return key;\n            }\n            var Class;\n            switch (alg.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.EcDH.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED, \"deriveBits\");\n            }\n            return Class.deriveKey(alg, baseKey, algDerivedKey, extractable, keyUsages);\n        });\n    };\n    SubtleCrypto.prototype.encrypt = function (algorithm, key, data) {\n        var args = arguments;\n        var alg;\n        var dataBytes;\n        return _super.prototype.encrypt.apply(this, args)\n            .then(function (bits) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            dataBytes = webcrypto_core_2.PrepareData(data, \"data\");\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.encrypt.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native 'encrypt' for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    helper_1.warn(\"WebCrypto: native 'encrypt' for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (msg) {\n            if (msg) {\n                if (helper_1.BrowserInfo().name === helper_1.Browser.IE &&\n                    alg.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.AesGCM &&\n                    msg.ciphertext) {\n                    // Concatenate values in IE\n                    var buf_1 = new Uint8Array(msg.ciphertext.byteLength + msg.tag.byteLength);\n                    var count_1 = 0;\n                    new Uint8Array(msg.ciphertext).forEach(function (v) { return buf_1[count_1++] = v; });\n                    new Uint8Array(msg.tag).forEach(function (v) { return buf_1[count_1++] = v; });\n                    msg = buf_1.buffer;\n                }\n                return Promise.resolve(msg);\n            }\n            var Class;\n            switch (alg.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.AesECB.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():\n                    Class = crypto_2.AesCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                    Class = crypto_4.RsaCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED, \"encrypt\");\n            }\n            return PrepareKey(key, Class)\n                .then(function (preparedKey) { return Class.encrypt(alg, preparedKey, dataBytes); });\n        });\n    };\n    SubtleCrypto.prototype.decrypt = function (algorithm, key, data) {\n        var args = arguments;\n        var alg;\n        var dataBytes;\n        return _super.prototype.decrypt.apply(this, args)\n            .then(function (bits) {\n            alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n            dataBytes = webcrypto_core_2.PrepareData(data, \"data\");\n            var dataBytes2 = dataBytes;\n            if (helper_1.BrowserInfo().name === helper_1.Browser.IE &&\n                alg.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.AesGCM) {\n                // Split buffer\n                var len = dataBytes.byteLength - (alg.tagLength / 8);\n                dataBytes2 = {\n                    ciphertext: dataBytes.buffer.slice(0, len),\n                    tag: dataBytes.buffer.slice(len, dataBytes.byteLength),\n                };\n            }\n            if (!key.key) {\n                return init_1.nativeSubtle.decrypt.call(init_1.nativeSubtle, alg, key, dataBytes2);\n            }\n            else {\n                var Class = void 0;\n                switch (alg.name.toLowerCase()) {\n                    case webcrypto_core_1.AlgorithmNames.AesECB.toLowerCase():\n                    case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():\n                    case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():\n                        Class = crypto_2.AesCrypto;\n                        break;\n                    case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                        Class = crypto_4.RsaCrypto;\n                        break;\n                    default:\n                        throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED, \"decrypt\");\n                }\n                return Class.decrypt(alg, key, dataBytes);\n            }\n        });\n    };\n    SubtleCrypto.prototype.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {\n        var args = arguments;\n        var alg;\n        return _super.prototype.wrapKey.apply(this, args)\n            .then(function (bits) {\n            alg = webcrypto_core_2.PrepareAlgorithm(wrapAlgorithm);\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.wrapKey.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native 'wrapKey' for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    helper_1.warn(\"WebCrypto: native 'wrapKey' for \" + alg.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (msg) {\n            if (msg) {\n                return msg;\n            }\n            var Class;\n            switch (alg.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.AesECB.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():\n                    Class = crypto_2.AesCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                    Class = crypto_4.RsaCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED, \"wrapKey\");\n            }\n            return Class.wrapKey(format, key, wrappingKey, alg);\n        });\n    };\n    SubtleCrypto.prototype.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\n        var _this = this;\n        var args = arguments;\n        var alg;\n        var algKey;\n        var dataBytes;\n        return _super.prototype.unwrapKey.apply(this, args)\n            .then(function (bits) {\n            alg = webcrypto_core_2.PrepareAlgorithm(unwrapAlgorithm);\n            algKey = webcrypto_core_2.PrepareAlgorithm(unwrappedKeyAlgorithm);\n            dataBytes = webcrypto_core_2.PrepareData(wrappedKey, \"wrappedKey\");\n            if (!unwrappingKey.key) {\n                return init_1.nativeSubtle.unwrapKey.apply(init_1.nativeSubtle, args)\n                    .catch(function (err) {\n                    // Edge throws errors on unwrapKey native functions\n                    // Use custom unwrap function\n                    return _this.decrypt(alg, unwrappingKey, wrappedKey)\n                        .then(function (decryptedData) {\n                        var preparedData;\n                        if (format === \"jwk\") {\n                            preparedData = JSON.parse(helper_1.buffer2string(new Uint8Array(decryptedData)));\n                        }\n                        else {\n                            preparedData = decryptedData;\n                        }\n                        return _this.importKey(format, preparedData, algKey, extractable, keyUsages);\n                    });\n                })\n                    .then(function (k) {\n                    if (k) {\n                        FixCryptoKeyUsages(k, keyUsages);\n                        return k;\n                    }\n                })\n                    .catch(function (error) {\n                    console.error(error);\n                    throw new Error(\"Cannot unwrap key from incoming data\");\n                });\n            }\n            else {\n                var Class = void 0;\n                switch (alg.name.toLowerCase()) {\n                    case webcrypto_core_1.AlgorithmNames.AesECB.toLowerCase():\n                    case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():\n                    case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():\n                        Class = crypto_2.AesCrypto;\n                        break;\n                    case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                        Class = crypto_4.RsaCrypto;\n                        break;\n                    default:\n                        throw new error_1.LinerError(error_1.LinerError.NOT_SUPPORTED, \"unwrapKey\");\n                }\n                return Class.unwrapKey(format, dataBytes, unwrappingKey, alg, algKey, extractable, keyUsages);\n            }\n        });\n    };\n    SubtleCrypto.prototype.exportKey = function (format, key) {\n        var args = arguments;\n        return _super.prototype.exportKey.apply(this, args)\n            .then(function () {\n            if (init_1.nativeSubtle) {\n                try {\n                    return init_1.nativeSubtle.exportKey.apply(init_1.nativeSubtle, args)\n                        .catch(function (e) {\n                        helper_1.warn(\"WebCrypto: native 'exportKey' for \" + key.algorithm.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                    });\n                }\n                catch (e) {\n                    helper_1.warn(\"WebCrypto: native 'exportKey' for \" + key.algorithm.name + \" doesn't work.\", e && e.message || \"Unknown message\");\n                }\n            }\n        })\n            .then(function (msg) {\n            if (msg) {\n                if (format === \"jwk\" && msg instanceof ArrayBuffer) {\n                    msg = helper_1.buffer2string(new Uint8Array(msg));\n                    msg = JSON.parse(msg);\n                }\n                var alg = GetHashAlgorithm(key);\n                if (!alg) {\n                    alg = helper_1.assign({}, key.algorithm);\n                }\n                FixExportJwk(msg, alg, key.usages);\n                return Promise.resolve(msg);\n            }\n            if (!key.key) {\n                throw new error_1.LinerError(\"Cannot export native CryptoKey from JS implementation\");\n            }\n            var Class;\n            switch (key.algorithm.name.toLowerCase()) {\n                case webcrypto_core_1.AlgorithmNames.AesECB.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():\n                    Class = crypto_2.AesCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.EcDH.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.EcDSA.toLowerCase():\n                    Class = crypto_5.EcCrypto;\n                    break;\n                case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase():\n                case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                    Class = crypto_4.RsaCrypto;\n                    break;\n                default:\n                    throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, key.algorithm.name.toLowerCase());\n            }\n            return Class.exportKey(format, key);\n        });\n    };\n    SubtleCrypto.prototype.importKey = function (format, keyData, algorithm, extractable, keyUsages) {\n        return __awaiter(this, void 0, void 0, function () {\n            var args, dataAny, bits, alg, browser, k, e_1, Class;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        args = { format: format, keyData: keyData, algorithm: algorithm, extractable: extractable, keyUsages: keyUsages };\n                        return [4 /*yield*/, _super.prototype.importKey.call(this, format, keyData, algorithm, extractable, keyUsages)];\n                    case 1:\n                        bits = _a.sent();\n                        alg = webcrypto_core_2.PrepareAlgorithm(algorithm);\n                        dataAny = keyData;\n                        browser = helper_1.BrowserInfo();\n                        if (format === \"jwk\" && ((browser.name === helper_1.Browser.Safari && !/^11/.test(browser.version)) ||\n                            browser.name === helper_1.Browser.IE)) {\n                            // Converts JWK to ArrayBuffer\n                            if (helper_1.BrowserInfo().name === helper_1.Browser.IE) {\n                                keyData = helper_1.assign({}, keyData);\n                                FixImportJwk(keyData);\n                            }\n                            args.keyData = helper_1.string2buffer(JSON.stringify(keyData)).buffer;\n                        }\n                        // End: Fix\n                        if (ArrayBuffer.isView(keyData)) {\n                            dataAny = webcrypto_core_2.PrepareData(keyData, \"keyData\");\n                        }\n                        if (CheckAppleRsaOAEP(alg.name)) {\n                            // Don't use native importKey for RSA-OAEP on Safari before v11\n                            // https://github.com/PeculiarVentures/webcrypto-liner/issues/53\n                            return [2 /*return*/];\n                        }\n                        if (!init_1.nativeSubtle) return [3 /*break*/, 5];\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, init_1.nativeSubtle.importKey.apply(init_1.nativeSubtle, args)];\n                    case 3:\n                        k = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _a.sent();\n                        helper_1.warn(\"WebCrypto: native 'importKey' for \" + alg.name + \" doesn't work.\", e_1 && e_1.message || \"Unknown message\");\n                        return [3 /*break*/, 5];\n                    case 5:\n                        if (k) {\n                            SetHashAlgorithm(alg, k);\n                            FixCryptoKeyUsages(k, keyUsages);\n                            return [2 /*return*/, Promise.resolve(k)];\n                        }\n                        switch (alg.name.toLowerCase()) {\n                            case webcrypto_core_1.AlgorithmNames.AesECB.toLowerCase():\n                            case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():\n                            case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():\n                                Class = crypto_2.AesCrypto;\n                                break;\n                            case webcrypto_core_1.AlgorithmNames.EcDH.toLowerCase():\n                            case webcrypto_core_1.AlgorithmNames.EdDSA.toLowerCase():\n                            case webcrypto_core_1.AlgorithmNames.EcDSA.toLowerCase():\n                                Class = crypto_5.EcCrypto;\n                                break;\n                            case webcrypto_core_1.AlgorithmNames.RsaSSA.toLowerCase():\n                            case webcrypto_core_1.AlgorithmNames.RsaPSS.toLowerCase():\n                            case webcrypto_core_1.AlgorithmNames.RsaOAEP.toLowerCase():\n                                Class = crypto_4.RsaCrypto;\n                                break;\n                            default:\n                                throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, alg.name.toLowerCase());\n                        }\n                        return [2 /*return*/, Class.importKey(format, dataAny, alg, extractable, keyUsages)];\n                }\n            });\n        });\n    };\n    return SubtleCrypto;\n}(core.SubtleCrypto));\nexports.SubtleCrypto = SubtleCrypto;\n// save hash alg for RSA keys\nfunction SetHashAlgorithm(alg, key) {\n    if ((helper_1.BrowserInfo().name === helper_1.Browser.IE || helper_1.BrowserInfo().name === helper_1.Browser.Edge || helper_1.BrowserInfo().name === helper_1.Browser.Safari) && /^rsa/i.test(alg.name)) {\n        if (key.privateKey) {\n            keys.push({ hash: alg.hash, key: key.privateKey });\n            keys.push({ hash: alg.hash, key: key.publicKey });\n        }\n        else {\n            keys.push({ hash: alg.hash, key: key });\n        }\n    }\n}\n// fix hash alg for rsa key\nfunction GetHashAlgorithm(key) {\n    var alg = null;\n    keys.some(function (item) {\n        if (item.key === key) {\n            alg = helper_1.assign({}, key.algorithm, { hash: item.hash });\n            return true;\n        }\n        return false;\n    });\n    return alg;\n}\n// Extend Uint8Array for IE\nif (!Uint8Array.prototype.forEach) {\n    // tslint:disable-next-line:only-arrow-functions\n    // tslint:disable-next-line:space-before-function-paren\n    Uint8Array.prototype.forEach = function (cb) {\n        for (var i = 0; i < this.length; i++) {\n            cb(this[i], i, this);\n        }\n    };\n}\nif (!Uint8Array.prototype.slice) {\n    // tslint:disable-next-line:only-arrow-functions\n    // tslint:disable-next-line:space-before-function-paren\n    Uint8Array.prototype.slice = function (start, end) {\n        return new Uint8Array(this.buffer.slice(start, end));\n    };\n}\nif (!Uint8Array.prototype.filter) {\n    // tslint:disable-next-line:only-arrow-functions\n    // tslint:disable-next-line:space-before-function-paren\n    Uint8Array.prototype.filter = function (cb) {\n        var buf = [];\n        for (var i = 0; i < this.length; i++) {\n            if (cb(this[i], i, this)) {\n                buf.push(this[i]);\n            }\n        }\n        return new Uint8Array(buf);\n    };\n}\nfunction FixCryptoKeyUsages(key, keyUsages) {\n    var keyArray = [];\n    if (key.privateKey) {\n        keyArray.push(key.privateKey);\n        keyArray.push(key.publicKey);\n    }\n    else {\n        keyArray.push(key);\n    }\n    keyArray.forEach(function (k) {\n        if (\"keyUsage\" in k) {\n            k.usages = k.keyUsage || [];\n            // add usages\n            if (!k.usages.length) {\n                [\"verify\", \"encrypt\", \"wrapKey\"]\n                    .forEach(function (usage) {\n                    if (keyUsages.indexOf(usage) > -1 && (k.type === \"public\" || k.type === \"secret\")) {\n                        k.usages.push(usage);\n                    }\n                });\n                [\"sign\", \"decrypt\", \"unwrapKey\", \"deriveKey\", \"deriveBits\"]\n                    .forEach(function (usage) {\n                    if (keyUsages.indexOf(usage) > -1 && (k.type === \"private\" || k.type === \"secret\")) {\n                        k.usages.push(usage);\n                    }\n                });\n            }\n        }\n    });\n}\nfunction FixExportJwk(jwk, alg, keyUsages) {\n    if (alg && helper_1.BrowserInfo().name === helper_1.Browser.IE) {\n        // ext\n        if (\"extractable\" in jwk) {\n            jwk.ext = jwk.extractable;\n            delete jwk.extractable;\n        }\n        // add alg\n        var CryptoClass = null;\n        switch (alg.name.toUpperCase()) {\n            case webcrypto_core_1.AlgorithmNames.RsaOAEP.toUpperCase():\n            case webcrypto_core_1.AlgorithmNames.RsaPSS.toUpperCase():\n            case webcrypto_core_1.AlgorithmNames.RsaSSA.toUpperCase():\n                CryptoClass = crypto_4.RsaCrypto;\n                break;\n            case webcrypto_core_1.AlgorithmNames.AesECB.toUpperCase():\n            case webcrypto_core_1.AlgorithmNames.AesCBC.toUpperCase():\n            case webcrypto_core_1.AlgorithmNames.AesGCM.toUpperCase():\n                CryptoClass = crypto_2.AesCrypto;\n                break;\n            default:\n                throw new error_1.LinerError(error_1.LinerError.UNSUPPORTED_ALGORITHM, alg.name.toUpperCase());\n        }\n        if (CryptoClass && !jwk.alg) {\n            jwk.alg = CryptoClass.alg2jwk(alg);\n        }\n        // add key_ops\n        if (!(\"key_ops\" in jwk)) {\n            jwk.key_ops = keyUsages;\n        }\n    }\n}\nfunction FixImportJwk(jwk) {\n    if (helper_1.BrowserInfo().name === helper_1.Browser.IE) {\n        // ext\n        if (\"ext\" in jwk) {\n            jwk.extractable = jwk.ext;\n            delete jwk.ext;\n        }\n        delete jwk.key_ops;\n        delete jwk.alg;\n    }\n}\nfunction CheckAppleRsaOAEP(algName) {\n    var version = /AppleWebKit\\/(\\d+)/.exec(self.navigator.userAgent);\n    return (algName.toUpperCase() === webcrypto_core_1.AlgorithmNames.RsaOAEP && version && parseInt(version[1], 10) < 604);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3VidGxlLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvLi9zcmMvc3VidGxlLnRzP2ViZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gQ29yZVxudmFyIHdlYmNyeXB0b19jb3JlXzEgPSByZXF1aXJlKFwid2ViY3J5cHRvLWNvcmVcIik7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJ3ZWJjcnlwdG8tY29yZVwiKTtcbnZhciB3ZWJjcnlwdG9fY29yZV8yID0gcmVxdWlyZShcIndlYmNyeXB0by1jb3JlXCIpO1xuLy8gQmFzZVxudmFyIGluaXRfMSA9IHJlcXVpcmUoXCIuL2luaXRcIik7XG52YXIgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi9jcnlwdG9cIik7XG52YXIgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xudmFyIGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuLy8gQ3J5cHRvXG52YXIgY3J5cHRvXzIgPSByZXF1aXJlKFwiLi9hZXMvY3J5cHRvXCIpO1xudmFyIGNyeXB0b18zID0gcmVxdWlyZShcIi4vc2hhL2NyeXB0b1wiKTtcbnZhciBjcnlwdG9fNCA9IHJlcXVpcmUoXCIuL3JzYS9jcnlwdG9cIik7XG52YXIgY3J5cHRvXzUgPSByZXF1aXJlKFwiLi9lYy9jcnlwdG9cIik7XG52YXIga2V5cyA9IFtdO1xuZnVuY3Rpb24gUHJlcGFyZUtleShrZXksIHN1YnRsZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChrZXkua2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2V5LmV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKFwiJ2tleScgaXMgTmF0aXZlIENyeXB0b0tleS4gSXQgY2FuJ3QgYmUgY29udmVydGVkIHRvIEpTIENyeXB0b0tleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjcnlwdG9fNiA9IG5ldyBjcnlwdG9fMS5DcnlwdG8oKTtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG9fNi5zdWJ0bGUuZXhwb3J0S2V5KFwiandrXCIsIGtleSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoandrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsZyA9IEdldEhhc2hBbGdvcml0aG0oa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYWxnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZyA9IGhlbHBlcl8xLmFzc2lnbihhbGcsIGtleS5hbGdvcml0aG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VidGxlLmltcG9ydEtleShcImp3a1wiLCBqd2ssIGFsZywgdHJ1ZSwga2V5LnVzYWdlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxudmFyIFN1YnRsZUNyeXB0byA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VidGxlQ3J5cHRvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnRsZUNyeXB0bygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTdWJ0bGVDcnlwdG8ucHJvdG90eXBlLmdlbmVyYXRlS2V5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGFsZztcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2VuZXJhdGVLZXkuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBhbGcgPSB3ZWJjcnlwdG9fY29yZV8yLlByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHZhciBicm93c2VyID0gaGVscGVyXzEuQnJvd3NlckluZm8oKTtcbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5uYW1lID09PSBoZWxwZXJfMS5Ccm93c2VyLkVkZ2UgJiYgYWxnLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNHQ00pIHx8XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gQUVTLUdDTSBrZXkgZ2VuZXJhdGlvbiwgYmVjYXVzZSBFZGdlIHRocm93cyBlcnJvcnMgb24gR0NNIGVuY3J5cHQsIGRlY3J5cHQsIHdyYXBLZXksIHVud3JhcEtleVxuICAgICAgICAgICAgICAgIENoZWNrQXBwbGVSc2FPQUVQKGFsZy5uYW1lKVxuICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIG5hdGl2ZSBnZW5lcmF0ZUtleSBmb3IgUlNBLU9BRVAgb24gU2FmYXJpIGJlZm9yZSB2MTFcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9QZWN1bGlhclZlbnR1cmVzL3dlYmNyeXB0by1saW5lci9pc3N1ZXMvNTNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbml0XzEubmF0aXZlU3VidGxlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRfMS5uYXRpdmVTdWJ0bGUuZ2VuZXJhdGVLZXkuYXBwbHkoaW5pdF8xLm5hdGl2ZVN1YnRsZSwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlIGdlbmVyYXRlS2V5IGZvciBcIiArIGFsZy5uYW1lICsgXCIgZG9lc24ndCB3b3JrLlwiLCBlICYmIGUubWVzc2FnZSB8fCBcIlVua25vd24gbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcl8xLndhcm4oXCJXZWJDcnlwdG86IG5hdGl2ZSBnZW5lcmF0ZUtleSBmb3IgXCIgKyBhbGcubmFtZSArIFwiIGRvZXNuJ3Qgd29yay5cIiwgZSAmJiBlLm1lc3NhZ2UgfHwgXCJVbmtub3duIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGdlbmVyYXRlZEtleXMpIHtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRLZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZ2VuZXJhdGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2FmYXJpIGlzc3VlXG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL1BlY3VsaWFyVmVudHVyZXMvd2ViY3J5cHRvLWxpbmVyL2lzc3Vlcy8zOVxuICAgICAgICAgICAgICAgICAqIGlmIHB1YmxpYyBrZXkgY2Fubm90IGJlIGV4cG9ydGVkIGluIGNvcnJlY3QgSldLIGZvcm1hdCwgdGhlbiBydW4gbmV3IGdlbmVyYXRlS2V5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGhlbHBlcl8xLkJyb3dzZXJJbmZvKCkubmFtZSA9PT0gaGVscGVyXzEuQnJvd3Nlci5TYWZhcmkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuRWNESC50b1VwcGVyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGcubmFtZS50b1VwcGVyQ2FzZSgpID09PSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVjRFNBLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdWJLZXlfMSA9IGdlbmVyYXRlZEtleXMucHVibGljS2V5O1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHBvcnRLZXkoXCJqd2tcIiwgcHViS2V5XzEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGp3aykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHBvcnRLZXkoXCJzcGtpXCIsIHB1YktleV8xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3BraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHdlYmNyeXB0b19jb3JlXzEuQmFzZTY0VXJsLmRlY29kZShqd2sueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gd2ViY3J5cHRvX2NvcmVfMS5CYXNlNjRVcmwuZGVjb2RlKGp3ay55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGtpQnVmID0gbmV3IFVpbnQ4QXJyYXkoc3BraSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGtpQnl0ZSA9IHNwa2lCdWZbc3BraUJ1Zi5sZW5ndGggLSBpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRCeXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCB5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50Qnl0ZSA9IHlbeS5sZW5ndGggLSBpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEJ5dGUgPSB4W3gubGVuZ3RoICsgeS5sZW5ndGggLSBpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BraUJ5dGUgIT09IHBvaW50Qnl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2VuZXJhdGUgbmV3IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcl8xLndhcm4oXCJXZWJDcnlwdG86IEVDIGtleSBoYXMgd3JvbmcgcHVibGljIGtleSBKV0suIEtleSBwYWlyIHdpbGwgYmUgcmVjcmVhdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRLZXlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXlzMikge1xuICAgICAgICAgICAgICAgICAgICBGaXhDcnlwdG9LZXlVc2FnZXMoa2V5czIsIGtleVVzYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIFNldEhhc2hBbGdvcml0aG0oYWxnLCBrZXlzMik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzMjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBDbGFzcztcbiAgICAgICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNFQ0IudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzQ0JDLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0dDTS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b18yLkFlc0NyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVjRFNBLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVjREgudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBjcnlwdG9fNS5FY0NyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYU9BRVAudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhUFNTLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYVNTQS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b180LlJzYUNyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGcubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDbGFzcy5nZW5lcmF0ZUtleShhbGcsIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnRsZUNyeXB0by5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgZGF0YSkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGFsZztcbiAgICAgICAgdmFyIGRhdGFCeXRlcztcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGlnZXN0LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgICAgICBkYXRhQnl0ZXMgPSB3ZWJjcnlwdG9fY29yZV8yLlByZXBhcmVEYXRhKGRhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIGlmIChpbml0XzEubmF0aXZlU3VidGxlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRfMS5uYXRpdmVTdWJ0bGUuZGlnZXN0LmFwcGx5KGluaXRfMS5uYXRpdmVTdWJ0bGUsIGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcl8xLndhcm4oXCJXZWJDcnlwdG86IG5hdGl2ZSBkaWdlc3QgZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlIGRpZ2VzdCBmb3IgXCIgKyBhbGcubmFtZSArIFwiIGRvZXNuJ3Qgd29yay5cIiwgZSAmJiBlLm1lc3NhZ2UgfHwgXCJVbmtub3duIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRpZ2VzdCkge1xuICAgICAgICAgICAgaWYgKGRpZ2VzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWdlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvXzMuU2hhQ3J5cHRvLmRpZ2VzdChhbGcsIGRhdGFCeXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYWxnO1xuICAgICAgICB2YXIgZGF0YUJ5dGVzO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zaWduLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgICAgICBkYXRhQnl0ZXMgPSB3ZWJjcnlwdG9fY29yZV8yLlByZXBhcmVEYXRhKGRhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIHZhciBhbGcyID0gR2V0SGFzaEFsZ29yaXRobShrZXkpO1xuICAgICAgICAgICAgaWYgKGFsZzIpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gaGVscGVyXzEuYXNzaWduKGFsZywgYWxnMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdF8xLm5hdGl2ZVN1YnRsZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0XzEubmF0aXZlU3VidGxlLnNpZ24uYXBwbHkoaW5pdF8xLm5hdGl2ZVN1YnRsZSwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlIHNpZ24gZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlIHNpZ24gZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIENsYXNzO1xuICAgICAgICAgICAgc3dpdGNoIChhbGcubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVjRFNBLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzUuRWNDcnlwdG87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5FZERTQS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b181LkVjQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhU1NBLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYVBTUy50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b180LlJzYUNyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGcubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcmVwYXJlS2V5KGtleSwgQ2xhc3MpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByZXBhcmVkS2V5KSB7IHJldHVybiBDbGFzcy5zaWduKGFsZywgcHJlcGFyZWRLZXksIGRhdGFCeXRlcyk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnRsZUNyeXB0by5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciBhbGc7XG4gICAgICAgIHZhciBzaWduYXR1cmVCeXRlcztcbiAgICAgICAgdmFyIGRhdGFCeXRlcztcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmVyaWZ5LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgICAgICBzaWduYXR1cmVCeXRlcyA9IHdlYmNyeXB0b19jb3JlXzIuUHJlcGFyZURhdGEoc2lnbmF0dXJlLCBcImRhdGFcIik7XG4gICAgICAgICAgICBkYXRhQnl0ZXMgPSB3ZWJjcnlwdG9fY29yZV8yLlByZXBhcmVEYXRhKGRhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIHZhciBhbGcyID0gR2V0SGFzaEFsZ29yaXRobShrZXkpO1xuICAgICAgICAgICAgaWYgKGFsZzIpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gaGVscGVyXzEuYXNzaWduKGFsZywgYWxnMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdF8xLm5hdGl2ZVN1YnRsZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0XzEubmF0aXZlU3VidGxlLnZlcmlmeS5hcHBseShpbml0XzEubmF0aXZlU3VidGxlLCBhcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJfMS53YXJuKFwiV2ViQ3J5cHRvOiBuYXRpdmUgdmVyaWZ5IGZvciBcIiArIGFsZy5uYW1lICsgXCIgZG9lc24ndCB3b3JrLlwiLCBlICYmIGUubWVzc2FnZSB8fCBcIlVua25vd24gbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcl8xLndhcm4oXCJXZWJDcnlwdG86IG5hdGl2ZSB2ZXJpZnkgZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQ2xhc3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuRWNEU0EudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBjcnlwdG9fNS5FY0NyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVkRFNBLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzUuRWNDcnlwdG87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FTU0EudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhUFNTLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzQuUnNhQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGFsZy5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByZXBhcmVLZXkoa2V5LCBDbGFzcylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJlcGFyZWRLZXkpIHsgcmV0dXJuIENsYXNzLnZlcmlmeShhbGcsIHByZXBhcmVkS2V5LCBzaWduYXR1cmVCeXRlcywgZGF0YUJ5dGVzKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5kZXJpdmVCaXRzID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYWxnO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZXJpdmVCaXRzLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYml0cykge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgICAgICBpZiAoaW5pdF8xLm5hdGl2ZVN1YnRsZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0XzEubmF0aXZlU3VidGxlLmRlcml2ZUJpdHMuYXBwbHkoaW5pdF8xLm5hdGl2ZVN1YnRsZSwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlIGRlcml2ZUJpdHMgZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWRnZSB0aHJvd3MgZXJyb3IuIERvbid0IGtub3cgV2h5LlxuICAgICAgICAgICAgICAgICAgICBoZWxwZXJfMS53YXJuKFwiV2ViQ3J5cHRvOiBuYXRpdmUgZGVyaXZlQml0cyBmb3IgXCIgKyBhbGcubmFtZSArIFwiIGRvZXNuJ3Qgd29yay5cIiwgZSAmJiBlLm1lc3NhZ2UgfHwgXCJVbmtub3duIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJpdHMpIHtcbiAgICAgICAgICAgIGlmIChiaXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQ2xhc3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuRWNESC50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b181LkVjQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5OT1RfU1VQUE9SVEVELCBcImRlcml2ZUJpdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2xhc3MuZGVyaXZlQml0cyhhbGcsIGJhc2VLZXksIGxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5kZXJpdmVLZXkgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGFsZztcbiAgICAgICAgdmFyIGFsZ0Rlcml2ZWRLZXk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlcml2ZUtleS5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJpdHMpIHtcbiAgICAgICAgICAgIGFsZyA9IHdlYmNyeXB0b19jb3JlXzIuUHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICAgICAgYWxnRGVyaXZlZEtleSA9IHdlYmNyeXB0b19jb3JlXzIuUHJlcGFyZUFsZ29yaXRobShkZXJpdmVkS2V5VHlwZSk7XG4gICAgICAgICAgICBpZiAoaW5pdF8xLm5hdGl2ZVN1YnRsZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0XzEubmF0aXZlU3VidGxlLmRlcml2ZUtleS5hcHBseShpbml0XzEubmF0aXZlU3VidGxlLCBhcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJfMS53YXJuKFwiV2ViQ3J5cHRvOiBuYXRpdmUgZGVyaXZlS2V5IGZvciBcIiArIGFsZy5uYW1lICsgXCIgZG9lc24ndCB3b3JrLlwiLCBlICYmIGUubWVzc2FnZSB8fCBcIlVua25vd24gbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVkZ2UgZG9lc24ndCBnbyB0byBjYXRjaCBvZiBQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcl8xLndhcm4oXCJXZWJDcnlwdG86IG5hdGl2ZSBkZXJpdmVLZXkgZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBGaXhDcnlwdG9LZXlVc2FnZXMoa2V5LCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQ2xhc3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuRWNESC50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b181LkVjQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5OT1RfU1VQUE9SVEVELCBcImRlcml2ZUJpdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2xhc3MuZGVyaXZlS2V5KGFsZywgYmFzZUtleSwgYWxnRGVyaXZlZEtleSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYWxnO1xuICAgICAgICB2YXIgZGF0YUJ5dGVzO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbmNyeXB0LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYml0cykge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgICAgICBkYXRhQnl0ZXMgPSB3ZWJjcnlwdG9fY29yZV8yLlByZXBhcmVEYXRhKGRhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIGlmIChpbml0XzEubmF0aXZlU3VidGxlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRfMS5uYXRpdmVTdWJ0bGUuZW5jcnlwdC5hcHBseShpbml0XzEubmF0aXZlU3VidGxlLCBhcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJfMS53YXJuKFwiV2ViQ3J5cHRvOiBuYXRpdmUgJ2VuY3J5cHQnIGZvciBcIiArIGFsZy5uYW1lICsgXCIgZG9lc24ndCB3b3JrLlwiLCBlICYmIGUubWVzc2FnZSB8fCBcIlVua25vd24gbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcl8xLndhcm4oXCJXZWJDcnlwdG86IG5hdGl2ZSAnZW5jcnlwdCcgZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyXzEuQnJvd3NlckluZm8oKS5uYW1lID09PSBoZWxwZXJfMS5Ccm93c2VyLklFICYmXG4gICAgICAgICAgICAgICAgICAgIGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzR0NNICYmXG4gICAgICAgICAgICAgICAgICAgIG1zZy5jaXBoZXJ0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbmNhdGVuYXRlIHZhbHVlcyBpbiBJRVxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmXzEgPSBuZXcgVWludDhBcnJheShtc2cuY2lwaGVydGV4dC5ieXRlTGVuZ3RoICsgbXNnLnRhZy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShtc2cuY2lwaGVydGV4dCkuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gYnVmXzFbY291bnRfMSsrXSA9IHY7IH0pO1xuICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShtc2cudGFnKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBidWZfMVtjb3VudF8xKytdID0gdjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IGJ1Zl8xLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIENsYXNzO1xuICAgICAgICAgICAgc3dpdGNoIChhbGcubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0VDQi50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNDQkMudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzR0NNLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzIuQWVzQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhT0FFUC50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b180LlJzYUNyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuTk9UX1NVUFBPUlRFRCwgXCJlbmNyeXB0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByZXBhcmVLZXkoa2V5LCBDbGFzcylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJlcGFyZWRLZXkpIHsgcmV0dXJuIENsYXNzLmVuY3J5cHQoYWxnLCBwcmVwYXJlZEtleSwgZGF0YUJ5dGVzKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYWxnO1xuICAgICAgICB2YXIgZGF0YUJ5dGVzO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZWNyeXB0LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYml0cykge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgICAgICBkYXRhQnl0ZXMgPSB3ZWJjcnlwdG9fY29yZV8yLlByZXBhcmVEYXRhKGRhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIHZhciBkYXRhQnl0ZXMyID0gZGF0YUJ5dGVzO1xuICAgICAgICAgICAgaWYgKGhlbHBlcl8xLkJyb3dzZXJJbmZvKCkubmFtZSA9PT0gaGVscGVyXzEuQnJvd3Nlci5JRSAmJlxuICAgICAgICAgICAgICAgIGFsZy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzR0NNKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYnVmZmVyXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGFCeXRlcy5ieXRlTGVuZ3RoIC0gKGFsZy50YWdMZW5ndGggLyA4KTtcbiAgICAgICAgICAgICAgICBkYXRhQnl0ZXMyID0ge1xuICAgICAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBkYXRhQnl0ZXMuYnVmZmVyLnNsaWNlKDAsIGxlbiksXG4gICAgICAgICAgICAgICAgICAgIHRhZzogZGF0YUJ5dGVzLmJ1ZmZlci5zbGljZShsZW4sIGRhdGFCeXRlcy5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXkua2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRfMS5uYXRpdmVTdWJ0bGUuZGVjcnlwdC5jYWxsKGluaXRfMS5uYXRpdmVTdWJ0bGUsIGFsZywga2V5LCBkYXRhQnl0ZXMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBDbGFzcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0VDQi50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzQ0JDLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNHQ00udG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzIuQWVzQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FPQUVQLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b180LlJzYUNyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuTk9UX1NVUFBPUlRFRCwgXCJkZWNyeXB0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xhc3MuZGVjcnlwdChhbGcsIGtleSwgZGF0YUJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJ0bGVDcnlwdG8ucHJvdG90eXBlLndyYXBLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXksIHdyYXBwaW5nS2V5LCB3cmFwQWxnb3JpdGhtKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYWxnO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS53cmFwS2V5LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYml0cykge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKHdyYXBBbGdvcml0aG0pO1xuICAgICAgICAgICAgaWYgKGluaXRfMS5uYXRpdmVTdWJ0bGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdF8xLm5hdGl2ZVN1YnRsZS53cmFwS2V5LmFwcGx5KGluaXRfMS5uYXRpdmVTdWJ0bGUsIGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcl8xLndhcm4oXCJXZWJDcnlwdG86IG5hdGl2ZSAnd3JhcEtleScgZm9yIFwiICsgYWxnLm5hbWUgKyBcIiBkb2Vzbid0IHdvcmsuXCIsIGUgJiYgZS5tZXNzYWdlIHx8IFwiVW5rbm93biBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlICd3cmFwS2V5JyBmb3IgXCIgKyBhbGcubmFtZSArIFwiIGRvZXNuJ3Qgd29yay5cIiwgZSAmJiBlLm1lc3NhZ2UgfHwgXCJVbmtub3duIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQ2xhc3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzRUNCLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0NCQy50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNHQ00udG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBjcnlwdG9fMi5BZXNDcnlwdG87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FPQUVQLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzQuUnNhQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5OT1RfU1VQUE9SVEVELCBcIndyYXBLZXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2xhc3Mud3JhcEtleShmb3JtYXQsIGtleSwgd3JhcHBpbmdLZXksIGFsZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS51bndyYXBLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCB3cmFwcGVkS2V5LCB1bndyYXBwaW5nS2V5LCB1bndyYXBBbGdvcml0aG0sIHVud3JhcHBlZEtleUFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGFsZztcbiAgICAgICAgdmFyIGFsZ0tleTtcbiAgICAgICAgdmFyIGRhdGFCeXRlcztcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudW53cmFwS2V5LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYml0cykge1xuICAgICAgICAgICAgYWxnID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlQWxnb3JpdGhtKHVud3JhcEFsZ29yaXRobSk7XG4gICAgICAgICAgICBhbGdLZXkgPSB3ZWJjcnlwdG9fY29yZV8yLlByZXBhcmVBbGdvcml0aG0odW53cmFwcGVkS2V5QWxnb3JpdGhtKTtcbiAgICAgICAgICAgIGRhdGFCeXRlcyA9IHdlYmNyeXB0b19jb3JlXzIuUHJlcGFyZURhdGEod3JhcHBlZEtleSwgXCJ3cmFwcGVkS2V5XCIpO1xuICAgICAgICAgICAgaWYgKCF1bndyYXBwaW5nS2V5LmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0XzEubmF0aXZlU3VidGxlLnVud3JhcEtleS5hcHBseShpbml0XzEubmF0aXZlU3VidGxlLCBhcmdzKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFZGdlIHRocm93cyBlcnJvcnMgb24gdW53cmFwS2V5IG5hdGl2ZSBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSB1bndyYXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlY3J5cHQoYWxnLCB1bndyYXBwaW5nS2V5LCB3cmFwcGVkS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVwYXJlZERhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImp3a1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZWREYXRhID0gSlNPTi5wYXJzZShoZWxwZXJfMS5idWZmZXIyc3RyaW5nKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlZERhdGEgPSBkZWNyeXB0ZWREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmltcG9ydEtleShmb3JtYXQsIHByZXBhcmVkRGF0YSwgYWxnS2V5LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEZpeENyeXB0b0tleVVzYWdlcyhrLCBrZXlVc2FnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdW53cmFwIGtleSBmcm9tIGluY29taW5nIGRhdGFcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgQ2xhc3MgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhbGcubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNFQ0IudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0NCQy50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzR0NNLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b18yLkFlc0NyeXB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhT0FFUC50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBjcnlwdG9fNC5Sc2FDcnlwdG87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLk5PVF9TVVBQT1JURUQsIFwidW53cmFwS2V5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xhc3MudW53cmFwS2V5KGZvcm1hdCwgZGF0YUJ5dGVzLCB1bndyYXBwaW5nS2V5LCBhbGcsIGFsZ0tleSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidGxlQ3J5cHRvLnByb3RvdHlwZS5leHBvcnRLZXkgPSBmdW5jdGlvbiAoZm9ybWF0LCBrZXkpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmV4cG9ydEtleS5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluaXRfMS5uYXRpdmVTdWJ0bGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdF8xLm5hdGl2ZVN1YnRsZS5leHBvcnRLZXkuYXBwbHkoaW5pdF8xLm5hdGl2ZVN1YnRsZSwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlICdleHBvcnRLZXknIGZvciBcIiArIGtleS5hbGdvcml0aG0ubmFtZSArIFwiIGRvZXNuJ3Qgd29yay5cIiwgZSAmJiBlLm1lc3NhZ2UgfHwgXCJVbmtub3duIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXJfMS53YXJuKFwiV2ViQ3J5cHRvOiBuYXRpdmUgJ2V4cG9ydEtleScgZm9yIFwiICsga2V5LmFsZ29yaXRobS5uYW1lICsgXCIgZG9lc24ndCB3b3JrLlwiLCBlICYmIGUubWVzc2FnZSB8fCBcIlVua25vd24gbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICBpZiAobXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqd2tcIiAmJiBtc2cgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBoZWxwZXJfMS5idWZmZXIyc3RyaW5nKG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBKU09OLnBhcnNlKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhbGcgPSBHZXRIYXNoQWxnb3JpdGhtKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxnID0gaGVscGVyXzEuYXNzaWduKHt9LCBrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRml4RXhwb3J0SndrKG1zZywgYWxnLCBrZXkudXNhZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleS5rZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKFwiQ2Fubm90IGV4cG9ydCBuYXRpdmUgQ3J5cHRvS2V5IGZyb20gSlMgaW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgQ2xhc3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0VDQi50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNDQkMudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzR0NNLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzIuQWVzQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuRWNESC50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5FY0RTQS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IGNyeXB0b181LkVjQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhU1NBLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYVBTUy50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FPQUVQLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzQuUnNhQ3J5cHRvO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5MaW5lckVycm9yKGVycm9yXzEuTGluZXJFcnJvci5VTlNVUFBPUlRFRF9BTEdPUklUSE0sIGtleS5hbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDbGFzcy5leHBvcnRLZXkoZm9ybWF0LCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnRsZUNyeXB0by5wcm90b3R5cGUuaW1wb3J0S2V5ID0gZnVuY3Rpb24gKGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzLCBkYXRhQW55LCBiaXRzLCBhbGcsIGJyb3dzZXIsIGssIGVfMSwgQ2xhc3M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0geyBmb3JtYXQ6IGZvcm1hdCwga2V5RGF0YToga2V5RGF0YSwgYWxnb3JpdGhtOiBhbGdvcml0aG0sIGV4dHJhY3RhYmxlOiBleHRyYWN0YWJsZSwga2V5VXNhZ2VzOiBrZXlVc2FnZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9zdXBlci5wcm90b3R5cGUuaW1wb3J0S2V5LmNhbGwodGhpcywgZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYml0cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZyA9IHdlYmNyeXB0b19jb3JlXzIuUHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUFueSA9IGtleURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyID0gaGVscGVyXzEuQnJvd3NlckluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiandrXCIgJiYgKChicm93c2VyLm5hbWUgPT09IGhlbHBlcl8xLkJyb3dzZXIuU2FmYXJpICYmICEvXjExLy50ZXN0KGJyb3dzZXIudmVyc2lvbikpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5uYW1lID09PSBoZWxwZXJfMS5Ccm93c2VyLklFKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnRzIEpXSyB0byBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWxwZXJfMS5Ccm93c2VySW5mbygpLm5hbWUgPT09IGhlbHBlcl8xLkJyb3dzZXIuSUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RGF0YSA9IGhlbHBlcl8xLmFzc2lnbih7fSwga2V5RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpeEltcG9ydEp3ayhrZXlEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5rZXlEYXRhID0gaGVscGVyXzEuc3RyaW5nMmJ1ZmZlcihKU09OLnN0cmluZ2lmeShrZXlEYXRhKSkuYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kOiBGaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoa2V5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQW55ID0gd2ViY3J5cHRvX2NvcmVfMi5QcmVwYXJlRGF0YShrZXlEYXRhLCBcImtleURhdGFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ2hlY2tBcHBsZVJzYU9BRVAoYWxnLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIG5hdGl2ZSBpbXBvcnRLZXkgZm9yIFJTQS1PQUVQIG9uIFNhZmFyaSBiZWZvcmUgdjExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1BlY3VsaWFyVmVudHVyZXMvd2ViY3J5cHRvLWxpbmVyL2lzc3Vlcy81M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5pdF8xLm5hdGl2ZVN1YnRsZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgNCwgLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBpbml0XzEubmF0aXZlU3VidGxlLmltcG9ydEtleS5hcHBseShpbml0XzEubmF0aXZlU3VidGxlLCBhcmdzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyXzEud2FybihcIldlYkNyeXB0bzogbmF0aXZlICdpbXBvcnRLZXknIGZvciBcIiArIGFsZy5uYW1lICsgXCIgZG9lc24ndCB3b3JrLlwiLCBlXzEgJiYgZV8xLm1lc3NhZ2UgfHwgXCJVbmtub3duIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRIYXNoQWxnb3JpdGhtKGFsZywgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRml4Q3J5cHRvS2V5VXNhZ2VzKGssIGtleVVzYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVzb2x2ZShrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFsZy5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuQWVzRUNCLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkFlc0NCQy50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNHQ00udG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBjcnlwdG9fMi5BZXNDcnlwdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5FY0RILnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVkRFNBLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLkVjRFNBLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzID0gY3J5cHRvXzUuRWNDcnlwdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FTU0EudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdlYmNyeXB0b19jb3JlXzEuQWxnb3JpdGhtTmFtZXMuUnNhUFNTLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYU9BRVAudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBjcnlwdG9fNC5Sc2FDcnlwdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkxpbmVyRXJyb3IoZXJyb3JfMS5MaW5lckVycm9yLlVOU1VQUE9SVEVEX0FMR09SSVRITSwgYWxnLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgQ2xhc3MuaW1wb3J0S2V5KGZvcm1hdCwgZGF0YUFueSwgYWxnLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnRsZUNyeXB0bztcbn0oY29yZS5TdWJ0bGVDcnlwdG8pKTtcbmV4cG9ydHMuU3VidGxlQ3J5cHRvID0gU3VidGxlQ3J5cHRvO1xuLy8gc2F2ZSBoYXNoIGFsZyBmb3IgUlNBIGtleXNcbmZ1bmN0aW9uIFNldEhhc2hBbGdvcml0aG0oYWxnLCBrZXkpIHtcbiAgICBpZiAoKGhlbHBlcl8xLkJyb3dzZXJJbmZvKCkubmFtZSA9PT0gaGVscGVyXzEuQnJvd3Nlci5JRSB8fCBoZWxwZXJfMS5Ccm93c2VySW5mbygpLm5hbWUgPT09IGhlbHBlcl8xLkJyb3dzZXIuRWRnZSB8fCBoZWxwZXJfMS5Ccm93c2VySW5mbygpLm5hbWUgPT09IGhlbHBlcl8xLkJyb3dzZXIuU2FmYXJpKSAmJiAvXnJzYS9pLnRlc3QoYWxnLm5hbWUpKSB7XG4gICAgICAgIGlmIChrZXkucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHsgaGFzaDogYWxnLmhhc2gsIGtleToga2V5LnByaXZhdGVLZXkgfSk7XG4gICAgICAgICAgICBrZXlzLnB1c2goeyBoYXNoOiBhbGcuaGFzaCwga2V5OiBrZXkucHVibGljS2V5IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5cy5wdXNoKHsgaGFzaDogYWxnLmhhc2gsIGtleToga2V5IH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gZml4IGhhc2ggYWxnIGZvciByc2Ega2V5XG5mdW5jdGlvbiBHZXRIYXNoQWxnb3JpdGhtKGtleSkge1xuICAgIHZhciBhbGcgPSBudWxsO1xuICAgIGtleXMuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgYWxnID0gaGVscGVyXzEuYXNzaWduKHt9LCBrZXkuYWxnb3JpdGhtLCB7IGhhc2g6IGl0ZW0uaGFzaCB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWxnO1xufVxuLy8gRXh0ZW5kIFVpbnQ4QXJyYXkgZm9yIElFXG5pZiAoIVVpbnQ4QXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25seS1hcnJvdy1mdW5jdGlvbnNcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuXG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNiKHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmlmICghVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25seS1hcnJvdy1mdW5jdGlvbnNcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuXG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgIH07XG59XG5pZiAoIVVpbnQ4QXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpvbmx5LWFycm93LWZ1bmN0aW9uc1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW5cbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYih0aGlzW2ldLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYpO1xuICAgIH07XG59XG5mdW5jdGlvbiBGaXhDcnlwdG9LZXlVc2FnZXMoa2V5LCBrZXlVc2FnZXMpIHtcbiAgICB2YXIga2V5QXJyYXkgPSBbXTtcbiAgICBpZiAoa2V5LnByaXZhdGVLZXkpIHtcbiAgICAgICAga2V5QXJyYXkucHVzaChrZXkucHJpdmF0ZUtleSk7XG4gICAgICAgIGtleUFycmF5LnB1c2goa2V5LnB1YmxpY0tleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBrZXlBcnJheS5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKFwia2V5VXNhZ2VcIiBpbiBrKSB7XG4gICAgICAgICAgICBrLnVzYWdlcyA9IGsua2V5VXNhZ2UgfHwgW107XG4gICAgICAgICAgICAvLyBhZGQgdXNhZ2VzXG4gICAgICAgICAgICBpZiAoIWsudXNhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIFtcInZlcmlmeVwiLCBcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh1c2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpID4gLTEgJiYgKGsudHlwZSA9PT0gXCJwdWJsaWNcIiB8fCBrLnR5cGUgPT09IFwic2VjcmV0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrLnVzYWdlcy5wdXNoKHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFtcInNpZ25cIiwgXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCIsIFwiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAodXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSA+IC0xICYmIChrLnR5cGUgPT09IFwicHJpdmF0ZVwiIHx8IGsudHlwZSA9PT0gXCJzZWNyZXRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsudXNhZ2VzLnB1c2godXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIEZpeEV4cG9ydEp3ayhqd2ssIGFsZywga2V5VXNhZ2VzKSB7XG4gICAgaWYgKGFsZyAmJiBoZWxwZXJfMS5Ccm93c2VySW5mbygpLm5hbWUgPT09IGhlbHBlcl8xLkJyb3dzZXIuSUUpIHtcbiAgICAgICAgLy8gZXh0XG4gICAgICAgIGlmIChcImV4dHJhY3RhYmxlXCIgaW4gandrKSB7XG4gICAgICAgICAgICBqd2suZXh0ID0gandrLmV4dHJhY3RhYmxlO1xuICAgICAgICAgICAgZGVsZXRlIGp3ay5leHRyYWN0YWJsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgYWxnXG4gICAgICAgIHZhciBDcnlwdG9DbGFzcyA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoYWxnLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSB3ZWJjcnlwdG9fY29yZV8xLkFsZ29yaXRobU5hbWVzLlJzYU9BRVAudG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FQU1MudG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FTU0EudG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBDcnlwdG9DbGFzcyA9IGNyeXB0b180LlJzYUNyeXB0bztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNFQ0IudG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNDQkMudG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgIGNhc2Ugd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5BZXNHQ00udG9VcHBlckNhc2UoKTpcbiAgICAgICAgICAgICAgICBDcnlwdG9DbGFzcyA9IGNyeXB0b18yLkFlc0NyeXB0bztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuTGluZXJFcnJvcihlcnJvcl8xLkxpbmVyRXJyb3IuVU5TVVBQT1JURURfQUxHT1JJVEhNLCBhbGcubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ3J5cHRvQ2xhc3MgJiYgIWp3ay5hbGcpIHtcbiAgICAgICAgICAgIGp3ay5hbGcgPSBDcnlwdG9DbGFzcy5hbGcyandrKGFsZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGtleV9vcHNcbiAgICAgICAgaWYgKCEoXCJrZXlfb3BzXCIgaW4gandrKSkge1xuICAgICAgICAgICAgandrLmtleV9vcHMgPSBrZXlVc2FnZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBGaXhJbXBvcnRKd2soandrKSB7XG4gICAgaWYgKGhlbHBlcl8xLkJyb3dzZXJJbmZvKCkubmFtZSA9PT0gaGVscGVyXzEuQnJvd3Nlci5JRSkge1xuICAgICAgICAvLyBleHRcbiAgICAgICAgaWYgKFwiZXh0XCIgaW4gandrKSB7XG4gICAgICAgICAgICBqd2suZXh0cmFjdGFibGUgPSBqd2suZXh0O1xuICAgICAgICAgICAgZGVsZXRlIGp3ay5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGp3ay5rZXlfb3BzO1xuICAgICAgICBkZWxldGUgandrLmFsZztcbiAgICB9XG59XG5mdW5jdGlvbiBDaGVja0FwcGxlUnNhT0FFUChhbGdOYW1lKSB7XG4gICAgdmFyIHZlcnNpb24gPSAvQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMoc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICByZXR1cm4gKGFsZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gd2ViY3J5cHRvX2NvcmVfMS5BbGdvcml0aG1OYW1lcy5Sc2FPQUVQICYmIHZlcnNpb24gJiYgcGFyc2VJbnQodmVyc2lvblsxXSwgMTApIDwgNjA0KTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/subtle.ts\n");

/***/ }),

/***/ "crypto":
/*!***************************************!*\
  !*** external "require(\"crypto\");" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZXIvZXh0ZXJuYWwgXCJyZXF1aXJlKFxcXCJjcnlwdG9cXFwiKTtcIj83NzQwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTs7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///crypto\n");

/***/ })

/******/ });